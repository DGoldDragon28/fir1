# FIR1

![alt tag](fir.png)

This is a library which implements an efficient FIR filter
in both floating point arithmetic and integer arithmetic.

The floating point class has also an adaptive filter
method for the LMS algorithm.


## Installation

### Linux / Unix / MACOSX

The build system is `cmake`. Install the library with
the standard sequence:
```
cmake .
make
sudo make install
sudo ldconfig
```
or for debugging run cmake with:
```cmake -DCMAKE_BUILD_TYPE="Debug" .```
By default optimised release libraries are generated.

### Windows

Under windows only the static library is generated which
should be used for your code development.

```
cmake -G "Visual Studio 15 2017 Win64" .
```
and then start Visual C++ and compile it. Usually
you want to compile both the release and debug
libraries because they are not compatible to each
other under Windows.



## How to use it

### Generating the FIR filter coefficients

You can set the coefficients either with a C floating point array or
with a text file containing the coefficients. The text file or
the floating point arrary with the
coefficients can easily be generated by Python or OCTAVE/MATLAB:

1. In Python use the `firwin` command to generate the coefficients:
```
# Sampling rate
fs = 1000
# bandstop between 45 and 55 Hz:
f1 = 45
f2 = 55
b = signal.firwin(999,[f1/fs*2,f2/fs*2])
np.savetxt("h.dat",b)
```
this text file can then be imported into the filter at
runtime or you turn the textfile into a C++ floating point array and
point the filter to it.

For fixed point you need to scale up the coefficients,
for example by 16 bits: np.savetxt("h.dat",b*65536)

2. In octave/MATLAB
```
octave:1> h=fir1(100,0.1);
octave:2> save 'h.dat' h -ascii
```
which creates the coefficients of a lowpass filter with 100 taps
and normalised cutoff 0.1 to Nyquist.

Again, for fixed point "h" needs to be scaled.

### Initialisation

1. for floating point FIR filters
```
Fir1 fir("h.dat");
```
or import the coefficients as a floating point array (double).
```
Fir1 fir(coefficients,number_of_coefficients)
```
2. for integer FIR filters
```
Fir1fixed fir("h_fixed.dat",12);
```
where the coefficients have been scaled up by 2^12 and the
filter will scale them down by this amount (with the help of
a bitshift operation).

### Realtime filtering

1. for double
```
double b = fir.filter(a);
```
2. for integer
```
int b = fir.filter(a);
```

## LMS algorithm

The least mean square algorithm adjusts the FIR coefficients w_k
with the help of an error signal
```
w_k(n+1) = w_k(n) + learning_rate * buffer_k(n) * error(n)
```
using the function `lms_update(error)` while performing
the filtering with `filter()`.

### How to use the filter

- Construct the Fir filter with all coefficients set to zero: `Fir1(nCoeff)`
- Set the learning_rate with the method `setLearningRate(learning_rate)`.
- The input of the filter is an additional signal which provides information how to minimise the error.
- Define your error which needs to be minimised: `error = input_signal - fir_filter_output`
- Feed the error back into the filter with the method `lms_update(error)`.

### Stability

The FIR filter itself is stable but the error signal changes the filter coefficients which
in turn change the error and so on. There is a rule of thumb that the learning rate
should be less than the "tap power" of the input signal which is just the sum of all
squared values held in the different taps:
```
learning_rate < 1/getTapInputPower()
```
That allows an adaptive learning rate which is called "normalised LMS". From
my experiments that works in theory but in practise the realtime value of getTapInputPower()
can make the algorithm easily unstable because it might suggest infinite learning rates
and can fluctuate wildly. A better approach is to keep the learning rate constant and rather
control the power of the input signal by, for example, normalising the input signal or limiting
it.

See the demo below which removes 50Hz from an ECG which uses a normalised 50Hz signal
which guarantees stability by design.


## Demos
Demo programs are in the "demo" directory which show how to use the
filters for both floating point and fixed point.
1. `firdemo` sends an impulse into the filter and you should see the impulse
response at its output.
2. `fixeddemo` filters an example ECG with 50Hz noise. The coefficients
are 12 bit and you can generate them either with OCTAVE/MATLAB or Python.
The scripts are also provided.
3. `lmsdemo` filters out 50Hz noise from an ECG with the help of
adaptive filtering by using the 50Hz powerline frequency as the input
to the filter. This can be replaced by any reference artefact signal
or signal which is correlated with the artefact.


## Credits

This library has been adapted form Graeme Hattan's original C code.

Enjoy!

Bernd Porr & Graeme Hattan
