{\rtf1\ansi\ansicpg1252\uc1 \deff0\deflang1033\deflangfe1033
{\fonttbl {\f0\froman\fcharset0\fprq2{\*\panose 02020603050405020304}Times New Roman;}
{\f1\fswiss\fcharset0\fprq2{\*\panose 020b0604020202020204}Arial;}
{\f2\fmodern\fcharset0\fprq1{\*\panose 02070309020205020404}Courier New;}
{\f3\froman\fcharset2\fprq2{\*\panose 05050102010706020507}Symbol;}
}
{\colortbl;\red0\green0\blue0;\red0\green0\blue255;\red0\green255\blue255;\red0\green255\blue0;\red255\green0\blue255;\red255\green0\blue0;\red255\green255\blue0;\red255\green255\blue255;\red0\green0\blue128;\red0\green128\blue128;\red0\green128\blue0;\red128\green0\blue128;\red128\green0\blue0;\red128\green128\blue0;\red128\green128\blue128;\red192\green192\blue192;\red0\green128\blue0;\red96\green64\blue32;\rede0\green128\blue0;\red128\green0\blue0;\red128\green96\blue32;\red0\green32\blue128;\red0\green128\blue128;\red255\green0\blue255;\red0\green0\blue0;\red112\green0\blue112;\red255\green0\blue0;}
{\stylesheet
{\widctlpar\adjustright \fs20\cgrid \snext0 Normal;}
{\paperw11900\paperh16840\margl1800\margr1800\margt1440\margb1440\gutter0\ltrsect}
{\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid \sbasedon0 \snext0 heading 1;}
{\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid \sbasedon0 \snext0 heading 2;}
{\s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid \sbasedon0 \snext0 heading 3;}
{\s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid \sbasedon0 \snext0 heading 4;}{\*\cs10 \additive Default Paragraph Font;}
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid \sbasedon0 \snext0 heading 5;}{\*\cs10 \additive Default Paragraph Font;}
{\s15\qc\sb240\sa60\widctlpar\outlinelevel0\adjustright \b\f1\fs32\kerning28\cgrid \sbasedon0 \snext15 Title;}
{\s16\qc\sa60\widctlpar\outlinelevel1\adjustright \f1\cgrid \sbasedon0 \snext16 Subtitle;}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid \sbasedon0 \snext17 BodyText;}
{\s18\widctlpar\fs22\cgrid \sbasedon0 \snext18 DenseText;}
{\s28\widctlpar\tqc\tx4320\tqr\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext28 header;}
{\s29\widctlpar\tqc\tx4320\tqr\tx8640\qr\adjustright \fs20\cgrid \sbasedon0 \snext29 footer;}
{\s30\li360\sa60\sb120\keepn\widctlpar\adjustright \b\f1\fs20\cgrid \sbasedon0 \snext30 GroupHeader;}
{\s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext41 Code Example 0;}
{\s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext42 Code Example 1;}
{\s42\li720\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext43 Code Example 2;}
{\s43\li1080\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext44 Code Example 3;}
{\s44\li1440\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext45 Code Example 4;}
{\s45\li1800\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext46 Code Example 5;}
{\s46\li2160\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext47 Code Example 6;}
{\s47\li2520\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext48 Code Example 7;}
{\s48\li2880\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext49 Code Example 8;}
{\s49\li3240\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext50 Code Example 9;}
{\s50\li3600\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext51 Code Example 10;}
{\s51\li3960\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext52 Code Example 11;}
{\s52\li4320\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext53 Code Example 12;}
{\s53\li4680\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext53 Code Example 13;}
{\s60\li0\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext61 List Continue 0;}
{\s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext62 List Continue 1;}
{\s62\li720\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext63 List Continue 2;}
{\s63\li1080\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext64 List Continue 3;}
{\s64\li1440\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext65 List Continue 4;}
{\s65\li1800\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext66 List Continue 5;}
{\s66\li2160\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext67 List Continue 6;}
{\s67\li2520\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext68 List Continue 7;}
{\s68\li2880\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext69 List Continue 8;}
{\s69\li3240\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext70 List Continue 9;}
{\s70\li3600\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext71 List Continue 10;}
{\s71\li3960\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext72 List Continue 11;}
{\s72\li4320\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext73 List Continue 12;}
{\s73\li4680\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext73 List Continue 13;}
{\s80\li0\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext81 DescContinue 0;}
{\s81\li360\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext82 DescContinue 1;}
{\s82\li720\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext83 DescContinue 2;}
{\s83\li1080\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext84 DescContinue 3;}
{\s84\li1440\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext85 DescContinue 4;}
{\s85\li1800\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext86 DescContinue 5;}
{\s86\li2160\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext87 DescContinue 6;}
{\s87\li2520\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext88 DescContinue 7;}
{\s88\li2880\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext89 DescContinue 8;}
{\s89\li3240\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext90 DescContinue 9;}
{\s90\li3600\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext91 DescContinue 10;}
{\s91\li3960\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext92 DescContinue 11;}
{\s92\li4320\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext93 DescContinue 12;}
{\s93\li4680\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext93 DescContinue 13;}
{\s100\li0\sa30\sb30\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext101 LatexTOC 0;}
{\s101\li360\sa27\sb27\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext102 LatexTOC 1;}
{\s102\li720\sa24\sb24\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext103 LatexTOC 2;}
{\s103\li1080\sa21\sb21\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext104 LatexTOC 3;}
{\s104\li1440\sa18\sb18\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext105 LatexTOC 4;}
{\s105\li1800\sa15\sb15\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext106 LatexTOC 5;}
{\s106\li2160\sa12\sb12\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext107 LatexTOC 6;}
{\s107\li2520\sa9\sb9\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext108 LatexTOC 7;}
{\s108\li2880\sa6\sb6\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext109 LatexTOC 8;}
{\s109\li3240\sa3\sb3\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext110 LatexTOC 9;}
{\s110\li3600\sa3\sb3\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext111 LatexTOC 10;}
{\s111\li3960\sa3\sb3\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext112 LatexTOC 11;}
{\s112\li4320\sa3\sb3\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext113 LatexTOC 12;}
{\s113\li4680\sa3\sb3\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext113 LatexTOC 13;}
{\s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext121 \sautoupd List Bullet 0;}
{\s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext122 \sautoupd List Bullet 1;}
{\s122\fi-360\li1080\widctlpar\jclisttab\tx1080{\*\pn \pnlvlbody\ilvl0\ls3\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext123 \sautoupd List Bullet 2;}
{\s123\fi-360\li1440\widctlpar\jclisttab\tx1440{\*\pn \pnlvlbody\ilvl0\ls4\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext124 \sautoupd List Bullet 3;}
{\s124\fi-360\li1800\widctlpar\jclisttab\tx1800{\*\pn \pnlvlbody\ilvl0\ls5\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext125 \sautoupd List Bullet 4;}
{\s125\fi-360\li2160\widctlpar\jclisttab\tx2160{\*\pn \pnlvlbody\ilvl0\ls6\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext126 \sautoupd List Bullet 5;}
{\s126\fi-360\li2520\widctlpar\jclisttab\tx2520{\*\pn \pnlvlbody\ilvl0\ls7\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext127 \sautoupd List Bullet 6;}
{\s127\fi-360\li2880\widctlpar\jclisttab\tx2880{\*\pn \pnlvlbody\ilvl0\ls8\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext128 \sautoupd List Bullet 7;}
{\s128\fi-360\li3240\widctlpar\jclisttab\tx3240{\*\pn \pnlvlbody\ilvl0\ls9\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext129 \sautoupd List Bullet 8;}
{\s129\fi-360\li3600\widctlpar\jclisttab\tx3600{\*\pn \pnlvlbody\ilvl0\ls10\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext130 \sautoupd List Bullet 9;}
{\s130\fi-360\li3960\widctlpar\jclisttab\tx3960{\*\pn \pnlvlbody\ilvl0\ls11\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext131 \sautoupd List Bullet 10;}
{\s131\fi-360\li4320\widctlpar\jclisttab\tx4320{\*\pn \pnlvlbody\ilvl0\ls12\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext132 \sautoupd List Bullet 11;}
{\s132\fi-360\li4680\widctlpar\jclisttab\tx4680{\*\pn \pnlvlbody\ilvl0\ls13\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext133 \sautoupd List Bullet 12;}
{\s133\fi-360\li5040\widctlpar\jclisttab\tx5040{\*\pn \pnlvlbody\ilvl0\ls14\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext133 \sautoupd List Bullet 13;}
{\s140\fi-360\li360\widctlpar\fs20\cgrid \sbasedon0 \snext141 \sautoupd List Enum 0;}
{\s141\fi-360\li720\widctlpar\fs20\cgrid \sbasedon0 \snext142 \sautoupd List Enum 1;}
{\s142\fi-360\li1080\widctlpar\fs20\cgrid \sbasedon0 \snext143 \sautoupd List Enum 2;}
{\s143\fi-360\li1440\widctlpar\fs20\cgrid \sbasedon0 \snext144 \sautoupd List Enum 3;}
{\s144\fi-360\li1800\widctlpar\fs20\cgrid \sbasedon0 \snext145 \sautoupd List Enum 4;}
{\s145\fi-360\li2160\widctlpar\fs20\cgrid \sbasedon0 \snext146 \sautoupd List Enum 5;}
{\s146\fi-360\li2520\widctlpar\fs20\cgrid \sbasedon0 \snext147 \sautoupd List Enum 6;}
{\s147\fi-360\li2880\widctlpar\fs20\cgrid \sbasedon0 \snext148 \sautoupd List Enum 7;}
{\s148\fi-360\li3240\widctlpar\fs20\cgrid \sbasedon0 \snext149 \sautoupd List Enum 8;}
{\s149\fi-360\li3600\widctlpar\fs20\cgrid \sbasedon0 \snext150 \sautoupd List Enum 9;}
{\s150\fi-360\li3960\widctlpar\fs20\cgrid \sbasedon0 \snext151 \sautoupd List Enum 10;}
{\s151\fi-360\li4320\widctlpar\fs20\cgrid \sbasedon0 \snext152 \sautoupd List Enum 11;}
{\s152\fi-360\li4680\widctlpar\fs20\cgrid \sbasedon0 \snext153 \sautoupd List Enum 12;}
{\s153\fi-360\li5040\widctlpar\fs20\cgrid \sbasedon0 \snext153 \sautoupd List Enum 13;}
}
{\info 
{\title {\comment fir1 }fir1}
{\comment Generated by doxygen1.9.3.}
{\creatim \yr2022\mo3\dy31\hr15\min49\sec50}
}\pard\plain 
\sectd\pgnlcrm
{\footer \s29\widctlpar\tqc\tx4320\tqr\tx8640\qr\adjustright \fs20\cgrid {\chpgn}}
\pard\plain \s16\qc\sa60\widctlpar\outlinelevel1\adjustright \f1\cgrid 
\vertalc\qc\par\par\par\par\par\par\par
\pard\plain \s15\qc\sb240\sa60\widctlpar\outlinelevel0\adjustright \b\f1\fs32\kerning28\cgrid 
{\field\fldedit {\*\fldinst TITLE \\*MERGEFORMAT}{\fldrslt fir1}}\par
\pard\plain \s16\qc\sa60\widctlpar\outlinelevel1\adjustright \f1\cgrid 
\par
\par\par\par\par\par\par\par\par\par\par\par\par
\pard\plain \s16\qc\sa60\widctlpar\outlinelevel1\adjustright \f1\cgrid 
{\field\fldedit {\*\fldinst AUTHOR \\*MERGEFORMAT}{\fldrslt AUTHOR}}\par
Version \par{\field\fldedit {\*\fldinst CREATEDATE \\*MERGEFORMAT}{\fldrslt Thu Mar 31 2022 }}\par
\page\page\vertalt
\pard\plain 
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid Table of Contents\par
\pard\plain \par
{\field\fldedit {\*\fldinst TOC \\f \\*MERGEFORMAT}{\fldrslt Table of contents}}\par
\pard\plain 
\sect \sbkpage \pgndec \pgnrestart
\sect \sectd \sbknone
{\footer \s29\widctlpar\tqc\tx4320\tqr\tx8640\qr\adjustright \fs20\cgrid {\chpgn}}

\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
AudioFile{\tc \v AudioFile}\par \pard\plain 
{\bkmkstart AAAAAAAACJ}
{\bkmkend AAAAAAAACJ}
\par \pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
  \par
A simple header-only C++ library for reading and writing audio files.\par
Current supported formats:\par
{
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
WAV\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
AIFF\par}
\par
{\bkmkstart AAAAAAAAAF}
{\bkmkend AAAAAAAAAF}
{{\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Author
\par}
{\tc\tcl2 \v Author}
{\b AudioFile} is written and maintained by Adam Stark.\par
{\f2 http://www.adamstark.co.uk}\par}
{\bkmkstart AAAAAAAAAG}
{\bkmkend AAAAAAAAAG}
{{\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Usage
\par}
{\tc\tcl2 \v Usage}
{\bkmkstart AAAAAAAAAH}
{\bkmkend AAAAAAAAAH}
{{\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Create an AudioFile object:
\par}
{\tc\tcl3 \v Create an AudioFile object:}
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid     #include "AudioFile.h"\par
\par
    AudioFile<double> audioFile;\par
}
 \par}
{\bkmkstart AAAAAAAAAI}
{\bkmkend AAAAAAAAAI}
{{\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Load an audio file:
\par}
{\tc\tcl3 \v Load an audio file:}
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid     audioFile.load ("/path/to/my/audiofile.wav");\par
}
 \par}
{\bkmkstart AAAAAAAAAJ}
{\bkmkend AAAAAAAAAJ}
{{\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Get some information about the loaded audio:
\par}
{\tc\tcl3 \v Get some information about the loaded audio:}
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid     int sampleRate = audioFile.getSampleRate();\par
    int bitDepth = audioFile.getBitDepth();\par
\par
    int numSamples = audioFile.getNumSamplesPerChannel();\par
    double lengthInSeconds = audioFile.getLengthInSeconds();\par
\par
    int numChannels = audioFile.getNumChannels();\par
    bool isMono = audioFile.isMono();\par
    bool isStereo = audioFile.isStereo();\par
\par
    // or, just use this quick shortcut to print a summary to the console\par
    audioFile.printSummary();\par
}
 \par}
{\bkmkstart AAAAAAAAAK}
{\bkmkend AAAAAAAAAK}
{{\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Access the samples directly:
\par}
{\tc\tcl3 \v Access the samples directly:}
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid     int channel = 0;\par
    int numSamples = audioFile.getNumSamplesPerChannel();\par
\par
    for (int i = 0; i < numSamples; i++)\par
    \{\par
            double currentSample = audioFile.samples[channel][i];\par
    \}\par
}
 \par}
{\bkmkstart AAAAAAAAAL}
{\bkmkend AAAAAAAAAL}
{{\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Replace the AudioFile audio buffer with another
\par}
{\tc\tcl3 \v Replace the AudioFile audio buffer with another}
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid     // 1. Create an AudioBuffer \par
    // (BTW, AudioBuffer is just a vector of vectors)\par
\par
    AudioFile<double>::AudioBuffer buffer;\par
\par
    // 2. Set to (e.g.) two channels\par
    buffer.resize (2);\par
\par
    // 3. Set number of samples per channel\par
    buffer[0].resize (100000);\par
    buffer[1].resize (100000);\par
\par
    // 4. do something here to fill the buffer with samples, e.g.\par
\par
    #include <math.h> // somewhere earler (for M_PI and sinf())\par
\par
    // then...\par
\par
    int numChannels = 2;\par
    int numSamplesPerChannel = 100000;\par
    float sampleRate = 44100.f;\par
    float frequency = 440.f;\par
\par
    for (int i = 0; i < numSamplesPerChannel; i++)\par
    \{\par
    float sample = sinf (2. * M_PI * ((float) i / sampleRate) * frequency) ;\par
\par
    for (int channel = 0; channel < numChannels; channel++)\par
         buffer[channel][i] = sample * 0.5;\par
    \}\par
\par
    // 5. Put into the AudioFile object\par
    bool ok = audioFile.setAudioBuffer (buffer);\par
}
\par}
{\bkmkstart AAAAAAAAAM}
{\bkmkend AAAAAAAAAM}
{{\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Resize the audio buffer
\par}
{\tc\tcl3 \v Resize the audio buffer}
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid     // Set both the number of channels and number of samples per channel\par
    audioFile.setAudioBufferSize (numChannels, numSamples);\par
\par
    // Set the number of samples per channel\par
    audioFile.setNumSamplesPerChannel (numSamples);\par
\par
    // Set the number of channels\par
    audioFile.setNumChannels (int numChannels);\par
}
 \par}
{\bkmkstart AAAAAAAAAN}
{\bkmkend AAAAAAAAAN}
{{\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Set bit depth and sample rate
\par}
{\tc\tcl3 \v Set bit depth and sample rate}
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid     audioFile.setBitDepth (24);\par
    audioFile.setSampleRate (44100);\par
}
 \par}
{\bkmkstart AAAAAAAAAO}
{\bkmkend AAAAAAAAAO}
{{\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Save the audio file to disk
\par}
{\tc\tcl3 \v Save the audio file to disk}
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid     // Wave file (implicit)\par
    audioFile.save ("path/to/desired/audioFile.wav");\par
\par
    // Wave file (explicit)\par
    audioFile.save ("path/to/desired/audioFile.wav", AudioFileFormat::Wave);\par
\par
    // Aiff file\par
    audioFile.save ("path/to/desired/audioFile.aif", AudioFileFormat::Aiff);\par
}
\par}
\par}
{\bkmkstart AAAAAAAAAP}
{\bkmkend AAAAAAAAAP}
{{\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Examples
\par}
{\tc\tcl2 \v Examples}
Please see the {\f2 examples}  folder for some examples on library usage.\par}
{\bkmkstart AAAAAAAAAQ}
{\bkmkend AAAAAAAAAQ}
{{\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
A Note On Types
\par}
{\tc\tcl2 \v A Note On Types}
{\b AudioFile} is a template class and so it can be instantiated using floating point precision: {
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid     AudioFile<float> audioFile;\par
}
 ...or double precision: {
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid     AudioFile<double> audioFile;\par
}
 This simply reflects the data type you would like to use to store the underlying audio samples. You can still read or write 8, 16 or 24-bit audio files, regardless of the type that you use (unless your system uses a precision for floats less than your desired bit depth).\par
I have heard of people using the library with other types, but I have not designed for those cases. Let me know if you are interested in this supporting a specific type more formally.\par}
{\bkmkstart AAAAAAAAAR}
{\bkmkend AAAAAAAAAR}
{{\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Error Messages
\par}
{\tc\tcl2 \v Error Messages}
By default, the library logs error messages to the console to provide information on what has gone wrong (e.g. a file we tried to load didn't exist).\par
If you prefer not to see these messages, you can disable this error logging behaviour using: {
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid     audioFile.shouldLogErrorsToConsole (false);\par
}
\par}
{\bkmkstart AAAAAAAAAS}
{\bkmkend AAAAAAAAAS}
{{\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Versions
\par}
{\tc\tcl2 \v Versions}
{\bkmkstart AAAAAAAAAT}
{\bkmkend AAAAAAAAAT}
{{\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
1.1.0 - 15th January 2022
\par}
{\tc\tcl4 \v 1.1.0 - 15th January 2022}
{
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Moved project to MIT licence\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Added option to load an audio file already in memory\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
CI Workflow improvements and bug fixes\par}
\par
\par}
{\bkmkstart AAAAAAAAAU}
{\bkmkend AAAAAAAAAU}
{{\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
1.0.9 - 23rd January 2021
\par}
{\tc\tcl4 \v 1.0.9 - 23rd January 2021}
{
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Faster loading of audio files\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Bug fixes\par}
\par
\par}
{\bkmkstart AAAAAAAAAV}
{\bkmkend AAAAAAAAAV}
{{\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
1.0.8 - 18th October 2020
\par}
{\tc\tcl4 \v 1.0.8 - 18th October 2020}
{
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
CMake support\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Construct instances with a file path\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Bug fixes\par}
\par
\par}
{\bkmkstart AAAAAAAAAW}
{\bkmkend AAAAAAAAAW}
{{\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
1.0.7 - 3rd July 2020
\par}
{\tc\tcl4 \v 1.0.7 - 3rd July 2020}
{
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Support for 32-bit audio files\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Support for multi-channel audio files\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Reading/writing of {\f2 iXML data chunks}\par}
\par
\par}
{\bkmkstart AAAAAAAAAX}
{\bkmkend AAAAAAAAAX}
{{\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
1.0.6 - 29th February 2020
\par}
{\tc\tcl4 \v 1.0.6 - 29th February 2020}
{
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Made error logging to the console optional\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Fixed lots of compiler warnings\par}
\par
\par}
{\bkmkstart AAAAAAAAAY}
{\bkmkend AAAAAAAAAY}
{{\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
1.0.5 - 14th October 2019
\par}
{\tc\tcl4 \v 1.0.5 - 14th October 2019}
{
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Added include of <algorithm> to better support Visual Studio\par}
\par
\par}
{\bkmkstart AAAAAAAAAZ}
{\bkmkend AAAAAAAAAZ}
{{\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
1.0.4 - 13th October 2019
\par}
{\tc\tcl4 \v 1.0.4 - 13th October 2019}
{
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Changed to a header-only library. Now you can just include {\b AudioFile.h}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Bug fixes\par}
\par
\par}
{\bkmkstart AAAAAAAABA}
{\bkmkend AAAAAAAABA}
{{\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
1.0.3 - 28th October 2018
\par}
{\tc\tcl4 \v 1.0.3 - 28th October 2018}
{
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Bug fixes\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Documentation updates\par}
\par
\par}
{\bkmkstart AAAAAAAABB}
{\bkmkend AAAAAAAABB}
{{\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
1.0.2 - 6th June 2017
\par}
{\tc\tcl4 \v 1.0.2 - 6th June 2017}
{
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Bug fixes\par}
\par
\par}
\par}
{\bkmkstart AAAAAAAABC}
{\bkmkend AAAAAAAABC}
{{\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Contributions
\par}
{\tc\tcl2 \v Contributions}
{
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Multichannel (i.e. >2 channels) audio file support ({\f2 Sidelobe})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Read/write of iXML data chunks ({\f2 mynameisjohn})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Remove warnings ({\f2 Abhinav1997})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Better support on Ubuntu ({\f2 BenjaminHinchliff})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Faster loading of audio files ({\f2 helloimmatt})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Improvements to Github Actions workflow ({\f2 emiro85})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Pull request review ({\f2 MatthieuHernandez})\par}
\par
\par}
{\bkmkstart AAAAAAAABD}
{\bkmkend AAAAAAAABD}
{{\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Want to Contribute?
\par}
{\tc\tcl2 \v Want to Contribute?}
If you would like to submit a pull request for this library, please do! But kindly follow the following simple guidelines...\par
{
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Make the changes as concise as is possible for the change you are proposing\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Avoid unnecessarily changing a large number of lines - e.g. commits changing the number of spaces in indentations on all lines (and so on)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Keep to the code style of this library which is the {\f2 JUCE Coding Standards}\par}
\par
\par}
{\bkmkstart AAAAAAAABE}
{\bkmkend AAAAAAAABE}
{{\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
License
\par}
{\tc\tcl2 \v License}
MIT License\par
Copyright (c) 2017 Adam Stark\par
Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\par
The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\par
THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. \par}
}}

\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
Signal Cleaner{\tc \v Signal Cleaner}\par \pard\plain 
{\bkmkstart AAAAAAAACK}
{\bkmkend AAAAAAAACK}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The {\f2 signal-cleaner}  tool may be used to run the lms fir algorithm on a noisey input file and produce a clean output file. The noise source is also required. All inputs are files with {\f2 .wav}  extenstion.\par
{\bkmkstart AAAAAAAABF}
{\bkmkend AAAAAAAABF}
{{\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Build
\par}
{\tc\tcl2 \v Build}
To try out {\f2 signal-cleaner} , you can build the program with {\f2 cmake}  from the root level {\f2 fir/}  directory or from this directory as shown:\par
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid cmake .\par
make\par
}
\par}
{\bkmkstart AAAAAAAABG}
{\bkmkend AAAAAAAABG}
{{\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Usage
\par}
{\tc\tcl2 \v Usage}
A usage example is provided below:\par
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid Usage: ./signal-cleaner[-l <lrate>] [-n <ntaps>] [-o <file>] <noise-source> [<input>]\par
}
\par
As well as providing input and noise sources, the {\f2 ntaps}  and {\f2 lrate}  for the filter may be configured.\par
If no output file is specified, the program will output to {\f2 stdout} .\par
If no input file is specified, the program will input from {\f2 stdin} .\par}
{\bkmkstart AAAAAAAABH}
{\bkmkend AAAAAAAABH}
{{\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Output
\par}
{\tc\tcl2 \v Output}
The output file is the filtered result. \par}
}}

\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
Correlate{\tc \v Correlate}\par \pard\plain 
{\bkmkstart AAAAAAAACL}
{\bkmkend AAAAAAAACL}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The {\f2 wave-correlate}  tool provides facility to compute standard deviation, covariance, pearsons correlation coeffiecient and SNR for input wav files.\par
{\bkmkstart AAAAAAAABI}
{\bkmkend AAAAAAAABI}
{{\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Build
\par}
{\tc\tcl2 \v Build}
To try out {\f2 wav-correlate} , you can build the program with {\f2 cmake}  from the root level {\f2 fir/}  directory or from this directory as shown:\par
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid cmake .\par
make\par
}
\par}
{\bkmkstart AAAAAAAABJ}
{\bkmkend AAAAAAAABJ}
{{\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Usage
\par}
{\tc\tcl2 \v Usage}
Example usage is shown:\par
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid Usage: wav-correlate <file1> [<file2>]\par
}
\par
If no secondary file is specified, the program will read from {\f2 stdin} .\par}
{\bkmkstart AAAAAAAABK}
{\bkmkend AAAAAAAABK}
{{\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Output
\par}
{\tc\tcl2 \v Output}
The program outputs metrics to {\f2 stdout} . Example program usage and output is shown:\par
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid $ correlate/wav-correlate wav-files/sinewave441Hz.wav wav-files/sinewave882Hz.wav\par
\par
MEAN1  : -3.05176e-07\par
MEAN2  : 0\par
STDEV1 : 0.707091\par
STDEV2 : 0.707095\par
COV    : 2.62016e-22\par
RHO    : 5.24051e-22\par
SNR    : -980.009 dB\par
}
 \par}
}}

\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
Class Index\par \pard\plain 
{\tc \v Class Index}
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Class List\par \pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Here are the classes, structs, unions and interfaces with brief descriptions:}
{
\par
\pard\plain \s101\li360\sa27\sb27\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
{\b {\b AudioFile< T >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAABL \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b SignalCleaner} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAACI \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
\par}
\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
File Index\par \pard\plain 
{\tc \v File Index}
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
File List\par \pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Here is a list of all documented files with brief descriptions:}
{
\par
\pard\plain \s101\li360\sa27\sb27\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
{\b AudioFile/{\b AudioFile.h} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAAD \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b correlate/{\b correlate.h} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAAB \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b SignalCleaner/{\b SignalCleaner.h} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAAC \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
\par}
\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
Class Documentation{\tc \v Class Documentation}
\par \pard\plain 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
AudioFile< T > Class Template Reference\par \pard\plain 
{\tc\tcl2 \v AudioFile< T >}
{\xe \v AudioFile< T >}
{\bkmkstart AAAAAAAABL}
{\bkmkend AAAAAAAABL}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b AudioFile} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b AudioFile} (std::string filePath)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b load} (std::string filePath)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b save} (std::string filePath, {\b AudioFileFormat} format=AudioFileFormat::Wave)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b loadFromMemory} (std::vector< uint8_t > &fileData)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint32_t {\b getSampleRate} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b getNumChannels} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b isMono} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b isStereo} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b getBitDepth} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b getNumSamplesPerChannel} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b getLengthInSeconds} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b printSummary} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b setAudioBuffer} (AudioBuffer &newBuffer)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setAudioBufferSize} (int numChannels, int numSamples)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setNumSamplesPerChannel} (int numSamples)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setNumChannels} (int numChannels)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setBitDepth} (int numBitsPerSample)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setSampleRate} (uint32_t newSampleRate)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b shouldLogErrorsToConsole} (bool logErrors)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
AudioBuffer {\b samples}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::string {\b iXMLChunk}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v AudioFile\:AudioFile< T >}
{\xe \v AudioFile< T >\:AudioFile}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class T > {\b AudioFile}< T >{\b ::AudioFile}}}
\par
{\bkmkstart AAAAAAAABM}
{\bkmkend AAAAAAAABM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Constructor \par
}}
{\xe \v AudioFile\:AudioFile< T >}
{\xe \v AudioFile< T >\:AudioFile}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class T > {\b AudioFile}< T >{\b ::AudioFile} (std::string  {\i filePath})}}
\par
{\bkmkstart AAAAAAAABN}
{\bkmkend AAAAAAAABN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Constructor, using a given file path to load a file \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v getBitDepth\:AudioFile< T >}
{\xe \v AudioFile< T >\:getBitDepth}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class T > int {\b AudioFile}< T >::getBitDepth}}
\par
{\bkmkstart AAAAAAAABO}
{\bkmkend AAAAAAAABO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
@Returns the bit depth of each sample \par
}}
{\xe \v getLengthInSeconds\:AudioFile< T >}
{\xe \v AudioFile< T >\:getLengthInSeconds}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class T > double {\b AudioFile}< T >::getLengthInSeconds}}
\par
{\bkmkstart AAAAAAAABP}
{\bkmkend AAAAAAAABP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
@Returns the length in seconds of the audio file based on the number of samples and sample rate \par
}}
{\xe \v getNumChannels\:AudioFile< T >}
{\xe \v AudioFile< T >\:getNumChannels}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class T > int {\b AudioFile}< T >::getNumChannels}}
\par
{\bkmkstart AAAAAAAABQ}
{\bkmkend AAAAAAAABQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
@Returns the number of audio channels in the buffer \par
}}
{\xe \v getNumSamplesPerChannel\:AudioFile< T >}
{\xe \v AudioFile< T >\:getNumSamplesPerChannel}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class T > int {\b AudioFile}< T >::getNumSamplesPerChannel}}
\par
{\bkmkstart AAAAAAAABR}
{\bkmkend AAAAAAAABR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
@Returns the number of samples per channel \par
}}
{\xe \v getSampleRate\:AudioFile< T >}
{\xe \v AudioFile< T >\:getSampleRate}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class T > uint32_t {\b AudioFile}< T >::getSampleRate}}
\par
{\bkmkstart AAAAAAAABS}
{\bkmkend AAAAAAAABS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
@Returns the sample rate \par
}}
{\xe \v isMono\:AudioFile< T >}
{\xe \v AudioFile< T >\:isMono}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class T > bool {\b AudioFile}< T >::isMono}}
\par
{\bkmkstart AAAAAAAABT}
{\bkmkend AAAAAAAABT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
@Returns true if the audio file is mono \par
}}
{\xe \v isStereo\:AudioFile< T >}
{\xe \v AudioFile< T >\:isStereo}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class T > bool {\b AudioFile}< T >::isStereo}}
\par
{\bkmkstart AAAAAAAABU}
{\bkmkend AAAAAAAABU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
@Returns true if the audio file is stereo \par
}}
{\xe \v load\:AudioFile< T >}
{\xe \v AudioFile< T >\:load}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class T > bool {\b AudioFile}< T >::load (std::string  {\i filePath})}}
\par
{\bkmkstart AAAAAAAABV}
{\bkmkend AAAAAAAABV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Loads an audio file from a given file path. @Returns true if the file was successfully loaded \par
}}
{\xe \v loadFromMemory\:AudioFile< T >}
{\xe \v AudioFile< T >\:loadFromMemory}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class T > bool {\b AudioFile}< T >::loadFromMemory (std::vector< uint8_t > &  {\i fileData})}}
\par
{\bkmkstart AAAAAAAABW}
{\bkmkend AAAAAAAABW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Loads an audio file from data in memory \par
}}
{\xe \v printSummary\:AudioFile< T >}
{\xe \v AudioFile< T >\:printSummary}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class T > void {\b AudioFile}< T >::printSummary}}
\par
{\bkmkstart AAAAAAAABX}
{\bkmkend AAAAAAAABX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Prints a summary of the audio file to the console \par
}}
{\xe \v save\:AudioFile< T >}
{\xe \v AudioFile< T >\:save}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class T > bool {\b AudioFile}< T >::save (std::string  {\i filePath}, {\b AudioFileFormat}  {\i format} = {\f2 AudioFileFormat::Wave})}}
\par
{\bkmkstart AAAAAAAABY}
{\bkmkend AAAAAAAABY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Saves an audio file to a given file path. @Returns true if the file was successfully saved \par
}}
{\xe \v setAudioBuffer\:AudioFile< T >}
{\xe \v AudioFile< T >\:setAudioBuffer}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class T > bool {\b AudioFile}< T >::setAudioBuffer (AudioBuffer &  {\i newBuffer})}}
\par
{\bkmkstart AAAAAAAABZ}
{\bkmkend AAAAAAAABZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Set the audio buffer for this {\b AudioFile} by copying samples from another buffer. @Returns true if the buffer was copied successfully. \par
}}
{\xe \v setAudioBufferSize\:AudioFile< T >}
{\xe \v AudioFile< T >\:setAudioBufferSize}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class T > void {\b AudioFile}< T >::setAudioBufferSize (int  {\i numChannels}, int  {\i numSamples})}}
\par
{\bkmkstart AAAAAAAACA}
{\bkmkend AAAAAAAACA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets the audio buffer to a given number of channels and number of samples per channel. This will try to preserve the existing audio, adding zeros to any new channels or new samples in a given channel. \par
}}
{\xe \v setBitDepth\:AudioFile< T >}
{\xe \v AudioFile< T >\:setBitDepth}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class T > void {\b AudioFile}< T >::setBitDepth (int  {\i numBitsPerSample})}}
\par
{\bkmkstart AAAAAAAACB}
{\bkmkend AAAAAAAACB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets the bit depth for the audio file. If you use the {\b save()} function, this bit depth rate will be used \par
}}
{\xe \v setNumChannels\:AudioFile< T >}
{\xe \v AudioFile< T >\:setNumChannels}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class T > void {\b AudioFile}< T >::setNumChannels (int  {\i numChannels})}}
\par
{\bkmkstart AAAAAAAACC}
{\bkmkend AAAAAAAACC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets the number of channels. New channels will have the correct number of samples and be initialised to zero \par
}}
{\xe \v setNumSamplesPerChannel\:AudioFile< T >}
{\xe \v AudioFile< T >\:setNumSamplesPerChannel}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class T > void {\b AudioFile}< T >::setNumSamplesPerChannel (int  {\i numSamples})}}
\par
{\bkmkstart AAAAAAAACD}
{\bkmkend AAAAAAAACD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets the number of samples per channel in the audio buffer. This will try to preserve the existing audio, adding zeros to new samples in a given channel if the number of samples is increased. \par
}}
{\xe \v setSampleRate\:AudioFile< T >}
{\xe \v AudioFile< T >\:setSampleRate}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class T > void {\b AudioFile}< T >::setSampleRate (uint32_t  {\i newSampleRate})}}
\par
{\bkmkstart AAAAAAAACE}
{\bkmkend AAAAAAAACE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets the sample rate for the audio file. If you use the {\b save()} function, this sample rate will be used \par
}}
{\xe \v shouldLogErrorsToConsole\:AudioFile< T >}
{\xe \v AudioFile< T >\:shouldLogErrorsToConsole}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class T > void {\b AudioFile}< T >::shouldLogErrorsToConsole (bool  {\i logErrors})}}
\par
{\bkmkstart AAAAAAAACF}
{\bkmkend AAAAAAAACF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets whether the library should log error messages to the console. By default this is true \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v iXMLChunk\:AudioFile< T >}
{\xe \v AudioFile< T >\:iXMLChunk}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class T > std::string {\b AudioFile}< T >::iXMLChunk}}
\par
{\bkmkstart AAAAAAAACG}
{\bkmkend AAAAAAAACG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
An optional iXML chunk that can be added to the {\b AudioFile}. \par
}}
{\xe \v samples\:AudioFile< T >}
{\xe \v AudioFile< T >\:samples}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class T > AudioBuffer {\b AudioFile}< T >::samples}}
\par
{\bkmkstart AAAAAAAACH}
{\bkmkend AAAAAAAACH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A vector of vectors holding the audio samples for the {\b AudioFile}. You can access the samples by channel and then by sample index, i.e: {
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  samples[channel][sampleIndex]\par
}
 \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
AudioFile/{\b AudioFile.h}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
SignalCleaner Class Reference\par \pard\plain 
{\tc\tcl2 \v SignalCleaner}
{\xe \v SignalCleaner}
{\bkmkstart AAAAAAAACI}
{\bkmkend AAAAAAAACI}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
SignalCleaner/SignalCleaner.h\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
SignalCleaner/SignalCleaner.cpp\par
}
\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
File Documentation{\tc \v File Documentation}
\par \pard\plain 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
AudioFile/AudioFile.h File Reference\par \pard\plain 
{\tc\tcl2 \v AudioFile/AudioFile.h}
{\xe \v AudioFile/AudioFile.h}
{\bkmkstart AAAAAAAAAD}
{\bkmkend AAAAAAAAAD}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <iostream>}\par
{\f2 #include <vector>}\par
{\f2 #include <cassert>}\par
{\f2 #include <string>}\par
{\f2 #include <cstring>}\par
{\f2 #include <fstream>}\par
{\f2 #include <unordered_map>}\par
{\f2 #include <iterator>}\par
{\f2 #include <algorithm>}\par
{\f2 #include <limits>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b AudioFile< T >}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Enumerations\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum class {\b AudioFileFormat} \par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Author\par}\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
Adam Stark \par
}}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Copyright\par}\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
Copyright (C) 2017 Adam Stark\par
}}This file is part of the '{\b AudioFile}' library\par
MIT License\par
Copyright (c) 2017 Adam Stark\par
Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\par
The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\par
THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Enumeration Type Documentation\par
\pard\plain 
{\xe \v AudioFileFormat\:AudioFile.h}
{\xe \v AudioFile.h\:AudioFileFormat}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
enum class {\b AudioFileFormat}{\f2 [strong]}}}
\par
{\bkmkstart AAAAAAAAAE}
{\bkmkend AAAAAAAAAE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The different types of audio file, plus some other types to indicate a failure to load a file, or that one hasn't been loaded yet \par
}}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
AudioFile.h\par \pard\plain 
{\tc\tcl2 \v AudioFile/AudioFile.h}
{\xe \v AudioFile/AudioFile.h}
{\bkmkstart AAAAAAAAAA}
{\bkmkend AAAAAAAAAA}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 1 {\cf20 //=======================================================================}\par
29 {\cf20 }{\cf20 //=======================================================================}\par
30 \par
31 {\cf21 #ifndef _AS_AudioFile_h}\par
32 {\cf21 #define _AS_AudioFile_h}\par
33 \par
34 {\cf21 #if defined (_MSC_VER)}\par
35 {\cf21 #undef max}\par
36 {\cf21 #undef min}\par
37 {\cf21 #define NOMINMAX}\par
38 {\cf21 #endif}\par
39 \par
40 {\cf21 #include <iostream>}\par
41 {\cf21 #include <vector>}\par
42 {\cf21 #include <cassert>}\par
43 {\cf21 #include <string>}\par
44 {\cf21 #include <cstring>}\par
45 {\cf21 #include <fstream>}\par
46 {\cf21 #include <unordered_map>}\par
47 {\cf21 #include <iterator>}\par
48 {\cf21 #include <algorithm>}\par
49 {\cf21 #include <limits>}\par
50 \par
51 {\cf20 // disable some warnings on Windows}\par
52 {\cf21 #if defined (_MSC_VER)}\par
53     __pragma(warning (push))\par
54     __pragma(warning (disable : 4244))\par
55     __pragma(warning (disable : 4457))\par
56     __pragma(warning (disable : 4458))\par
57     __pragma(warning (disable : 4389))\par
58     __pragma(warning (disable : 4996))\par
59 {\cf21 #elif defined (__GNUC__)}\par
60     _Pragma({\cf22 "GCC diagnostic push"})\par
61     _Pragma("GCC diagnostic ignored \\"-Wconversion\\"")\par
62     _Pragma("GCC diagnostic ignored \\"-Wsign-compare\\"")\par
63     _Pragma("GCC diagnostic ignored \\"-Wshadow\\"")\par
64 {\cf21 #endif}\par
65 \par
66 {\cf20 //=============================================================}\par
71 {\cf20 }{\cf17 enum class} AudioFileFormat\par
72 \{\par
73     Error,\par
74     NotLoaded,\par
75     Wave,\par
76     Aiff\par
77 \};\par
78 \par
79 {\cf20 //=============================================================}\par
80 {\cf17 template} <{\cf17 class} T>\par
81 {\cf17 class }AudioFile\par
82 \{\par
83 {\cf17 public}:\par
84     \par
85     {\cf20 //=============================================================}\par
86     {\cf17 typedef} std::vector<std::vector<T> > AudioBuffer;\par
87     \par
88     {\cf20 //=============================================================}\par
90 {\cf20 }    AudioFile();\par
91     \par
93     AudioFile (std::string filePath);\par
94         \par
95     {\cf20 //=============================================================}\par
99 {\cf20 }    {\cf18 bool} load (std::string filePath);\par
100     \par
104     {\cf18 bool} save (std::string filePath, AudioFileFormat format = AudioFileFormat::Wave);\par
105         \par
106     {\cf20 //=============================================================}\par
108 {\cf20 }    {\cf18 bool} loadFromMemory (std::vector<uint8_t>& fileData);\par
109     \par
110     {\cf20 //=============================================================}\par
112 {\cf20 }    uint32_t getSampleRate() {\cf17 const};\par
113     \par
115     {\cf18 int} getNumChannels() {\cf17 const};\par
116 \par
118     {\cf18 bool} isMono() {\cf17 const};\par
119     \par
121     {\cf18 bool} isStereo() {\cf17 const};\par
122     \par
124     {\cf18 int} getBitDepth() {\cf17 const};\par
125     \par
127     {\cf18 int} getNumSamplesPerChannel() {\cf17 const};\par
128     \par
130     {\cf18 double} getLengthInSeconds() {\cf17 const};\par
131     \par
133     {\cf18 void} printSummary() {\cf17 const};\par
134     \par
135     {\cf20 //=============================================================}\par
136     \par
140     {\cf18 bool} setAudioBuffer (AudioBuffer& newBuffer);\par
141     \par
145     {\cf18 void} setAudioBufferSize ({\cf18 int} numChannels, {\cf18 int} numSamples);\par
146     \par
150     {\cf18 void} setNumSamplesPerChannel ({\cf18 int} numSamples);\par
151     \par
153     {\cf18 void} setNumChannels ({\cf18 int} numChannels);\par
154     \par
156     {\cf18 void} setBitDepth ({\cf18 int} numBitsPerSample);\par
157     \par
159     {\cf18 void} setSampleRate (uint32_t newSampleRate);\par
160     \par
161     {\cf20 //=============================================================}\par
163 {\cf20 }    {\cf18 void} shouldLogErrorsToConsole ({\cf18 bool} logErrors);\par
164     \par
165     {\cf20 //=============================================================}\par
171 {\cf20 }    AudioBuffer samples;\par
172     \par
173     {\cf20 //=============================================================}\par
176 {\cf20 }    std::string iXMLChunk;\par
177     \par
178 {\cf17 private}:\par
179     \par
180     {\cf20 //=============================================================}\par
181     {\cf17 enum class} Endianness\par
182     \{\par
183         LittleEndian,\par
184         BigEndian\par
185     \};\par
186     \par
187     {\cf20 //=============================================================}\par
188     AudioFileFormat determineAudioFileFormat (std::vector<uint8_t>& fileData);\par
189     {\cf18 bool} decodeWaveFile (std::vector<uint8_t>& fileData);\par
190     {\cf18 bool} decodeAiffFile (std::vector<uint8_t>& fileData);\par
191     \par
192     {\cf20 //=============================================================}\par
193     {\cf18 bool} saveToWaveFile (std::string filePath);\par
194     {\cf18 bool} saveToAiffFile (std::string filePath);\par
195     \par
196     {\cf20 //=============================================================}\par
197     {\cf18 void} clearAudioBuffer();\par
198     \par
199     {\cf20 //=============================================================}\par
200     int32_t fourBytesToInt (std::vector<uint8_t>& source, {\cf18 int} startIndex, Endianness endianness = Endianness::LittleEndian);\par
201     int16_t twoBytesToInt (std::vector<uint8_t>& source, {\cf18 int} startIndex, Endianness endianness = Endianness::LittleEndian);\par
202     {\cf18 int} getIndexOfString (std::vector<uint8_t>& source, std::string s);\par
203     {\cf18 int} getIndexOfChunk (std::vector<uint8_t>& source, {\cf17 const} std::string& chunkHeaderID, {\cf18 int} startIndex, Endianness endianness = Endianness::LittleEndian);\par
204     \par
205     {\cf20 //=============================================================}\par
206     T sixteenBitIntToSample (int16_t sample);\par
207     int16_t sampleToSixteenBitInt (T sample);\par
208     \par
209     {\cf20 //=============================================================}\par
210     uint8_t sampleToSingleByte (T sample);\par
211     T singleByteToSample (uint8_t sample);\par
212     \par
213     uint32_t getAiffSampleRate (std::vector<uint8_t>& fileData, {\cf18 int} sampleRateStartIndex);\par
214     {\cf18 bool} tenByteMatch (std::vector<uint8_t>& v1, {\cf18 int} startIndex1, std::vector<uint8_t>& v2, {\cf18 int} startIndex2);\par
215     {\cf18 void} addSampleRateToAiffData (std::vector<uint8_t>& fileData, uint32_t sampleRate);\par
216     T clamp (T v1, T minValue, T maxValue);\par
217     \par
218     {\cf20 //=============================================================}\par
219     {\cf18 void} addStringToFileData (std::vector<uint8_t>& fileData, std::string s);\par
220     {\cf18 void} addInt32ToFileData (std::vector<uint8_t>& fileData, int32_t i, Endianness endianness = Endianness::LittleEndian);\par
221     {\cf18 void} addInt16ToFileData (std::vector<uint8_t>& fileData, int16_t i, Endianness endianness = Endianness::LittleEndian);\par
222     \par
223     {\cf20 //=============================================================}\par
224     {\cf18 bool} writeDataToFile (std::vector<uint8_t>& fileData, std::string filePath);\par
225     \par
226     {\cf20 //=============================================================}\par
227     {\cf18 void} reportError (std::string errorMessage);\par
228     \par
229     {\cf20 //=============================================================}\par
230     AudioFileFormat audioFileFormat;\par
231     uint32_t sampleRate;\par
232     {\cf18 int} bitDepth;\par
233     {\cf18 bool} logErrorsToConsole \{{\cf17 true}\};\par
234 \};\par
235 \par
236 \par
237 {\cf20 //=============================================================}\par
238 {\cf20 // Pre-defined 10-byte representations of common sample rates}\par
239 {\cf17 static} std::unordered_map <uint32_t, std::vector<uint8_t>> aiffSampleRateTable = \{\par
240     \{8000, \{64, 11, 250, 0, 0, 0, 0, 0, 0, 0\}\},\par
241     \{11025, \{64, 12, 172, 68, 0, 0, 0, 0, 0, 0\}\},\par
242     \{16000, \{64, 12, 250, 0, 0, 0, 0, 0, 0, 0\}\},\par
243     \{22050, \{64, 13, 172, 68, 0, 0, 0, 0, 0, 0\}\},\par
244     \{32000, \{64, 13, 250, 0, 0, 0, 0, 0, 0, 0\}\},\par
245     \{37800, \{64, 14, 147, 168, 0, 0, 0, 0, 0, 0\}\},\par
246     \{44056, \{64, 14, 172, 24, 0, 0, 0, 0, 0, 0\}\},\par
247     \{44100, \{64, 14, 172, 68, 0, 0, 0, 0, 0, 0\}\},\par
248     \{47250, \{64, 14, 184, 146, 0, 0, 0, 0, 0, 0\}\},\par
249     \{48000, \{64, 14, 187, 128, 0, 0, 0, 0, 0, 0\}\},\par
250     \{50000, \{64, 14, 195, 80, 0, 0, 0, 0, 0, 0\}\},\par
251     \{50400, \{64, 14, 196, 224, 0, 0, 0, 0, 0, 0\}\},\par
252     \{88200, \{64, 15, 172, 68, 0, 0, 0, 0, 0, 0\}\},\par
253     \{96000, \{64, 15, 187, 128, 0, 0, 0, 0, 0, 0\}\},\par
254     \{176400, \{64, 16, 172, 68, 0, 0, 0, 0, 0, 0\}\},\par
255     \{192000, \{64, 16, 187, 128, 0, 0, 0, 0, 0, 0\}\},\par
256     \{352800, \{64, 17, 172, 68, 0, 0, 0, 0, 0, 0\}\},\par
257     \{2822400, \{64, 20, 172, 68, 0, 0, 0, 0, 0, 0\}\},\par
258     \{5644800, \{64, 21, 172, 68, 0, 0, 0, 0, 0, 0\}\}\par
259 \};\par
260 \par
261 {\cf20 //=============================================================}\par
262 {\cf17 enum} WavAudioFormat\par
263 \{\par
264     PCM = 0x0001,\par
265     IEEEFloat = 0x0003,\par
266     ALaw = 0x0006,\par
267     MULaw = 0x0007,\par
268     Extensible = 0xFFFE\par
269 \};\par
270 \par
271 {\cf20 //=============================================================}\par
272 {\cf17 enum} AIFFAudioFormat\par
273 \{\par
274     Uncompressed,\par
275     Compressed,\par
276     Error\par
277 \};\par
278 \par
279 {\cf20 //=============================================================}\par
280 {\cf20 /* IMPLEMENTATION */}\par
281 {\cf20 //=============================================================}\par
282 \par
283 {\cf20 //=============================================================}\par
284 {\cf17 template} <{\cf17 class} T>\par
285 AudioFile<T>::AudioFile()\par
286 \{\par
287     {\cf17 static_assert}(std::is_floating_point<T>::value, {\cf22 "ERROR: This version of AudioFile only supports floating point sample formats"});\par
288 \par
289     bitDepth = 16;\par
290     sampleRate = 44100;\par
291     samples.resize (1);\par
292     samples[0].resize (0);\par
293     audioFileFormat = AudioFileFormat::NotLoaded;\par
294 \}\par
295 \par
296 {\cf20 //=============================================================}\par
297 {\cf17 template} <{\cf17 class} T>\par
298 AudioFile<T>::AudioFile (std::string filePath)\par
299  :  AudioFile<T>()\par
300 \{\par
301     load (filePath);\par
302 \}\par
303 \par
304 {\cf20 //=============================================================}\par
305 {\cf17 template} <{\cf17 class} T>\par
306 uint32_t AudioFile<T>::getSampleRate(){\cf17  const}\par
307 {\cf17 }\{\par
308     {\cf19 return} sampleRate;\par
309 \}\par
310 \par
311 {\cf20 //=============================================================}\par
312 {\cf17 template} <{\cf17 class} T>\par
313 {\cf18 int} AudioFile<T>::getNumChannels(){\cf17  const}\par
314 {\cf17 }\{\par
315     {\cf19 return} ({\cf18 int})samples.size();\par
316 \}\par
317 \par
318 {\cf20 //=============================================================}\par
319 {\cf17 template} <{\cf17 class} T>\par
320 {\cf18 bool} AudioFile<T>::isMono(){\cf17  const}\par
321 {\cf17 }\{\par
322     {\cf19 return} getNumChannels() == 1;\par
323 \}\par
324 \par
325 {\cf20 //=============================================================}\par
326 {\cf17 template} <{\cf17 class} T>\par
327 {\cf18 bool} AudioFile<T>::isStereo(){\cf17  const}\par
328 {\cf17 }\{\par
329     {\cf19 return} getNumChannels() == 2;\par
330 \}\par
331 \par
332 {\cf20 //=============================================================}\par
333 {\cf17 template} <{\cf17 class} T>\par
334 {\cf18 int} AudioFile<T>::getBitDepth(){\cf17  const}\par
335 {\cf17 }\{\par
336     {\cf19 return} bitDepth;\par
337 \}\par
338 \par
339 {\cf20 //=============================================================}\par
340 {\cf17 template} <{\cf17 class} T>\par
341 {\cf18 int} AudioFile<T>::getNumSamplesPerChannel(){\cf17  const}\par
342 {\cf17 }\{\par
343     {\cf19 if} (samples.size() > 0)\par
344         {\cf19 return} ({\cf18 int}) samples[0].size();\par
345     {\cf19 else}\par
346         {\cf19 return} 0;\par
347 \}\par
348 \par
349 {\cf20 //=============================================================}\par
350 {\cf17 template} <{\cf17 class} T>\par
351 {\cf18 double} AudioFile<T>::getLengthInSeconds(){\cf17  const}\par
352 {\cf17 }\{\par
353     {\cf19 return} ({\cf18 double})getNumSamplesPerChannel() / (double)sampleRate;\par
354 \}\par
355 \par
356 {\cf20 //=============================================================}\par
357 {\cf17 template} <{\cf17 class} T>\par
358 {\cf18 void} AudioFile<T>::printSummary(){\cf17  const}\par
359 {\cf17 }\{\par
360     std::cout << {\cf22 "|======================================|"} << std::endl;\par
361     std::cout << {\cf22 "Num Channels: "} << getNumChannels() << std::endl;\par
362     std::cout << {\cf22 "Num Samples Per Channel: "} << getNumSamplesPerChannel() << std::endl;\par
363     std::cout << {\cf22 "Sample Rate: "} << sampleRate << std::endl;\par
364     std::cout << {\cf22 "Bit Depth: "} << bitDepth << std::endl;\par
365     std::cout << {\cf22 "Length in Seconds: "} << getLengthInSeconds() << std::endl;\par
366     std::cout << {\cf22 "|======================================|"} << std::endl;\par
367 \}\par
368 \par
369 {\cf20 //=============================================================}\par
370 {\cf17 template} <{\cf17 class} T>\par
371 {\cf18 bool} AudioFile<T>::setAudioBuffer (AudioBuffer& newBuffer)\par
372 \{\par
373     {\cf18 int} numChannels = (int)newBuffer.size();\par
374     \par
375     {\cf19 if} (numChannels <= 0)\par
376     \{\par
377         assert ({\cf17 false} && {\cf22 "The buffer your are trying to use has no channels"});\par
378         {\cf19 return} {\cf17 false};\par
379     \}\par
380     \par
381     {\cf18 size_t} numSamples = newBuffer[0].size();\par
382     \par
383     {\cf20 // set the number of channels}\par
384     samples.resize (newBuffer.size());\par
385     \par
386     {\cf19 for} ({\cf18 int} k = 0; k < getNumChannels(); k++)\par
387     \{\par
388         assert (newBuffer[k].size() == numSamples);\par
389         \par
390         samples[k].resize (numSamples);\par
391         \par
392         {\cf19 for} ({\cf18 size_t} i = 0; i < numSamples; i++)\par
393         \{\par
394             samples[k][i] = newBuffer[k][i];\par
395         \}\par
396     \}\par
397     \par
398     {\cf19 return} {\cf17 true};\par
399 \}\par
400 \par
401 {\cf20 //=============================================================}\par
402 {\cf17 template} <{\cf17 class} T>\par
403 {\cf18 void} AudioFile<T>::setAudioBufferSize ({\cf18 int} numChannels, {\cf18 int} numSamples)\par
404 \{\par
405     samples.resize (numChannels);\par
406     setNumSamplesPerChannel (numSamples);\par
407 \}\par
408 \par
409 {\cf20 //=============================================================}\par
410 {\cf17 template} <{\cf17 class} T>\par
411 {\cf18 void} AudioFile<T>::setNumSamplesPerChannel ({\cf18 int} numSamples)\par
412 \{\par
413     {\cf18 int} originalSize = getNumSamplesPerChannel();\par
414     \par
415     {\cf19 for} ({\cf18 int} i = 0; i < getNumChannels();i++)\par
416     \{\par
417         samples[i].resize (numSamples);\par
418         \par
419         {\cf20 // set any new samples to zero}\par
420         {\cf19 if} (numSamples > originalSize)\par
421             std::fill (samples[i].begin() + originalSize, samples[i].end(), (T)0.);\par
422     \}\par
423 \}\par
424 \par
425 {\cf20 //=============================================================}\par
426 {\cf17 template} <{\cf17 class} T>\par
427 {\cf18 void} AudioFile<T>::setNumChannels ({\cf18 int} numChannels)\par
428 \{\par
429     {\cf18 int} originalNumChannels = getNumChannels();\par
430     {\cf18 int} originalNumSamplesPerChannel = getNumSamplesPerChannel();\par
431     \par
432     samples.resize (numChannels);\par
433     \par
434     {\cf20 // make sure any new channels are set to the right size}\par
435     {\cf20 // and filled with zeros}\par
436     {\cf19 if} (numChannels > originalNumChannels)\par
437     \{\par
438         {\cf19 for} ({\cf18 int} i = originalNumChannels; i < numChannels; i++)\par
439         \{\par
440             samples[i].resize (originalNumSamplesPerChannel);\par
441             std::fill (samples[i].begin(), samples[i].end(), (T)0.);\par
442         \}\par
443     \}\par
444 \}\par
445 \par
446 {\cf20 //=============================================================}\par
447 {\cf17 template} <{\cf17 class} T>\par
448 {\cf18 void} AudioFile<T>::setBitDepth ({\cf18 int} numBitsPerSample)\par
449 \{\par
450     bitDepth = numBitsPerSample;\par
451 \}\par
452 \par
453 {\cf20 //=============================================================}\par
454 {\cf17 template} <{\cf17 class} T>\par
455 {\cf18 void} AudioFile<T>::setSampleRate (uint32_t newSampleRate)\par
456 \{\par
457     sampleRate = newSampleRate;\par
458 \}\par
459 \par
460 {\cf20 //=============================================================}\par
461 {\cf17 template} <{\cf17 class} T>\par
462 {\cf18 void} AudioFile<T>::shouldLogErrorsToConsole ({\cf18 bool} logErrors)\par
463 \{\par
464     logErrorsToConsole = logErrors;\par
465 \}\par
466 \par
467 {\cf20 //=============================================================}\par
468 {\cf17 template} <{\cf17 class} T>\par
469 {\cf18 bool} AudioFile<T>::load (std::string filePath)\par
470 \{\par
471     std::ifstream file (filePath, std::ios::binary);\par
472     \par
473     {\cf20 // check the file exists}\par
474     {\cf19 if} (! file.good())\par
475     \{\par
476         reportError ({\cf22 "ERROR: File doesn't exist or otherwise can't load file\\n"}  + filePath);\par
477         {\cf19 return} {\cf17 false};\par
478     \}\par
479 \par
480     std::vector<uint8_t> fileData;\par
481 \par
482         file.unsetf (std::ios::skipws);\par
483 \par
484         file.seekg (0, std::ios::end);\par
485         {\cf18 size_t} length = file.tellg();\par
486         file.seekg (0, std::ios::beg);\par
487     std::cout << {\cf22 "len: "} << length;\par
488         {\cf20 // allocate}\par
489         fileData.resize (length);\par
490 \par
491         file.read({\cf17 reinterpret_cast<}{\cf18 char}*{\cf17 >} (fileData.data()), length);\par
492         file.close();\par
493 \par
494         {\cf19 if} (file.gcount() != length)\par
495         \{\par
496                 reportError ({\cf22 "ERROR: Couldn't read entire file\\n"} + filePath);\par
497                 {\cf19 return} {\cf17 false};\par
498         \}\par
499     \par
500     {\cf19 return} loadFromMemory (fileData);\par
501 \}\par
502 \par
503 {\cf20 //=============================================================}\par
504 {\cf17 template} <{\cf17 class} T>\par
505 {\cf18 bool} AudioFile<T>::loadFromMemory (std::vector<uint8_t>& fileData)\par
506 \{\par
507     {\cf20 // get audio file format}\par
508     audioFileFormat = determineAudioFileFormat (fileData);\par
509     \par
510     {\cf19 if} (audioFileFormat == AudioFileFormat::Wave)\par
511     \{\par
512         {\cf19 return} decodeWaveFile (fileData);\par
513     \}\par
514     {\cf19 else} {\cf19 if} (audioFileFormat == AudioFileFormat::Aiff)\par
515     \{\par
516         {\cf19 return} decodeAiffFile (fileData);\par
517     \}\par
518     {\cf19 else}\par
519     \{\par
520         reportError ({\cf22 "Audio File Type: Error"});\par
521         {\cf19 return} {\cf17 false};\par
522     \}\par
523 \}\par
524 \par
525 {\cf20 //=============================================================}\par
526 {\cf17 template} <{\cf17 class} T>\par
527 {\cf18 bool} AudioFile<T>::decodeWaveFile (std::vector<uint8_t>& fileData)\par
528 \{\par
529     {\cf20 // -----------------------------------------------------------}\par
530     {\cf20 // HEADER CHUNK}\par
531     std::string headerChunkID (fileData.begin(), fileData.begin() + 4);\par
532     {\cf20 //int32_t fileSizeInBytes = fourBytesToInt (fileData, 4) + 8;}\par
533     std::string format (fileData.begin() + 8, fileData.begin() + 12);\par
534     \par
535     {\cf20 // -----------------------------------------------------------}\par
536     {\cf20 // try and find the start points of key chunks}\par
537     {\cf18 int} indexOfDataChunk = getIndexOfChunk (fileData, {\cf22 "data"}, 12);\par
538     {\cf18 int} indexOfFormatChunk = getIndexOfChunk (fileData, {\cf22 "fmt "}, 12);\par
539     {\cf18 int} indexOfXMLChunk = getIndexOfChunk (fileData, {\cf22 "iXML"}, 12);\par
540     \par
541     {\cf20 // if we can't find the data or format chunks, or the IDs/formats don't seem to be as expected}\par
542     {\cf20 // then it is unlikely we'll able to read this file, so abort}\par
543     {\cf19 if} (indexOfDataChunk == -1 || indexOfFormatChunk == -1 || headerChunkID != {\cf22 "RIFF"} || format != {\cf22 "WAVE"})\par
544     \{\par
545         reportError ({\cf22 "ERROR: this doesn't seem to be a valid .WAV file"});\par
546         {\cf19 return} {\cf17 false};\par
547     \}\par
548     \par
549     {\cf20 // -----------------------------------------------------------}\par
550     {\cf20 // FORMAT CHUNK}\par
551     {\cf18 int} f = indexOfFormatChunk;\par
552     std::string formatChunkID (fileData.begin() + f, fileData.begin() + f + 4);\par
553     {\cf20 //int32_t formatChunkSize = fourBytesToInt (fileData, f + 4);}\par
554     uint16_t audioFormat = twoBytesToInt (fileData, f + 8);\par
555     uint16_t numChannels = twoBytesToInt (fileData, f + 10);\par
556     sampleRate = (uint32_t) fourBytesToInt (fileData, f + 12);\par
557     uint32_t numBytesPerSecond = fourBytesToInt (fileData, f + 16);\par
558     uint16_t numBytesPerBlock = twoBytesToInt (fileData, f + 20);\par
559     bitDepth = (int) twoBytesToInt (fileData, f + 22);\par
560     \par
561     uint16_t numBytesPerSample = {\cf17 static_cast<}uint16_t{\cf17 >} (bitDepth) / 8;\par
562     \par
563     {\cf20 // check that the audio format is PCM or Float or extensible}\par
564     {\cf19 if} (audioFormat != WavAudioFormat::PCM && audioFormat != WavAudioFormat::IEEEFloat && audioFormat != WavAudioFormat::Extensible)\par
565     \{\par
566         reportError ({\cf22 "ERROR: this .WAV file is encoded in a format that this library does not support at present"});\par
567         {\cf19 return} {\cf17 false};\par
568     \}\par
569     \par
570     {\cf20 // check the number of channels is mono or stereo}\par
571     {\cf19 if} (numChannels < 1 || numChannels > 128)\par
572     \{\par
573         reportError ({\cf22 "ERROR: this WAV file seems to be an invalid number of channels (or corrupted?)"});\par
574         {\cf19 return} {\cf17 false};\par
575     \}\par
576     \par
577     {\cf20 // check header data is consistent}\par
578     {\cf19 if} (numBytesPerSecond != {\cf17 static_cast<}uint32_t{\cf17 >} ((numChannels * sampleRate * bitDepth) / 8) || numBytesPerBlock != (numChannels * numBytesPerSample))\par
579     \{\par
580         reportError ({\cf22 "ERROR: the header data in this WAV file seems to be inconsistent"});\par
581         {\cf19 return} {\cf17 false};\par
582     \}\par
583     \par
584     {\cf20 // check bit depth is either 8, 16, 24 or 32 bit}\par
585     {\cf19 if} (bitDepth != 8 && bitDepth != 16 && bitDepth != 24 && bitDepth != 32)\par
586     \{\par
587         reportError ({\cf22 "ERROR: this file has a bit depth that is not 8, 16, 24 or 32 bits"});\par
588         {\cf19 return} {\cf17 false};\par
589     \}\par
590     \par
591     {\cf20 // -----------------------------------------------------------}\par
592     {\cf20 // DATA CHUNK}\par
593     {\cf18 int} d = indexOfDataChunk;\par
594     std::string dataChunkID (fileData.begin() + d, fileData.begin() + d + 4);\par
595     int32_t dataChunkSize = fourBytesToInt (fileData, d + 4);\par
596     \par
597     {\cf18 int} numSamples = dataChunkSize / (numChannels * bitDepth / 8);\par
598     {\cf18 int} samplesStartIndex = indexOfDataChunk + 8;\par
599     \par
600     clearAudioBuffer();\par
601     samples.resize (numChannels);\par
602     \par
603     {\cf19 for} ({\cf18 int} i = 0; i < numSamples; i++)\par
604     \{\par
605         {\cf19 for} ({\cf18 int} channel = 0; channel < numChannels; channel++)\par
606         \{\par
607             {\cf18 int} sampleIndex = samplesStartIndex + (numBytesPerBlock * i) + channel * numBytesPerSample;\par
608             \par
609             {\cf19 if} ((sampleIndex + (bitDepth / 8) - 1) >= fileData.size())\par
610             \{\par
611                 reportError ({\cf22 "ERROR: read file error as the metadata indicates more samples than there are in the file data"});\par
612                 {\cf19 return} {\cf17 false};\par
613             \}\par
614             \par
615             {\cf19 if} (bitDepth == 8)\par
616             \{\par
617                 T sample = singleByteToSample (fileData[sampleIndex]);\par
618                 samples[channel].push_back (sample);\par
619             \}\par
620             {\cf19 else} {\cf19 if} (bitDepth == 16)\par
621             \{\par
622                 int16_t sampleAsInt = twoBytesToInt (fileData, sampleIndex);\par
623                 T sample = sixteenBitIntToSample (sampleAsInt);\par
624                 samples[channel].push_back (sample);\par
625             \}\par
626             {\cf19 else} {\cf19 if} (bitDepth == 24)\par
627             \{\par
628                 int32_t sampleAsInt = 0;\par
629                 sampleAsInt = (fileData[sampleIndex + 2] << 16) | (fileData[sampleIndex + 1] << 8) | fileData[sampleIndex];\par
630                 \par
631                 {\cf19 if} (sampleAsInt & 0x800000) {\cf20 //  if the 24th bit is set, this is a negative number in 24-bit world}\par
632                     sampleAsInt = sampleAsInt | ~0xFFFFFF; {\cf20 // so make sure sign is extended to the 32 bit float}\par
633 \par
634                 T sample = (T)sampleAsInt / (T)8388608.;\par
635                 samples[channel].push_back (sample);\par
636             \}\par
637             {\cf19 else} {\cf19 if} (bitDepth == 32)\par
638             \{\par
639                 int32_t sampleAsInt = fourBytesToInt (fileData, sampleIndex);\par
640                 T sample;\par
641                 \par
642                 {\cf19 if} (audioFormat == WavAudioFormat::IEEEFloat)\par
643                     sample = (T){\cf17 reinterpret_cast<}{\cf18 float}&{\cf17 >} (sampleAsInt);\par
644                 {\cf19 else} {\cf20 // assume PCM}\par
645                     sample = (T) sampleAsInt / {\cf17 static_cast<}{\cf18 float}{\cf17 >} (std::numeric_limits<std::int32_t>::max());\par
646                 \par
647                 samples[channel].push_back (sample);\par
648             \}\par
649             {\cf19 else}\par
650             \{\par
651                 assert ({\cf17 false});\par
652             \}\par
653         \}\par
654     \}\par
655 \par
656     {\cf20 // -----------------------------------------------------------}\par
657     {\cf20 // iXML CHUNK}\par
658     {\cf19 if} (indexOfXMLChunk != -1)\par
659     \{\par
660         int32_t chunkSize = fourBytesToInt (fileData, indexOfXMLChunk + 4);\par
661         iXMLChunk = std::string (({\cf17 const} {\cf18 char}*) &fileData[indexOfXMLChunk + 8], chunkSize);\par
662     \}\par
663 \par
664     {\cf19 return} {\cf17 true};\par
665 \}\par
666 \par
667 {\cf20 //=============================================================}\par
668 {\cf17 template} <{\cf17 class} T>\par
669 {\cf18 bool} AudioFile<T>::decodeAiffFile (std::vector<uint8_t>& fileData)\par
670 \{\par
671     {\cf20 // -----------------------------------------------------------}\par
672     {\cf20 // HEADER CHUNK}\par
673     std::string headerChunkID (fileData.begin(), fileData.begin() + 4);\par
674     {\cf20 //int32_t fileSizeInBytes = fourBytesToInt (fileData, 4, Endianness::BigEndian) + 8;}\par
675     std::string format (fileData.begin() + 8, fileData.begin() + 12);\par
676     \par
677     {\cf18 int} audioFormat = format == {\cf22 "AIFF"} ? AIFFAudioFormat::Uncompressed : format == {\cf22 "AIFC"} ? AIFFAudioFormat::Compressed : AIFFAudioFormat::Error;\par
678     \par
679     {\cf20 // -----------------------------------------------------------}\par
680     {\cf20 // try and find the start points of key chunks}\par
681     {\cf18 int} indexOfCommChunk = getIndexOfChunk (fileData, {\cf22 "COMM"}, 12, Endianness::BigEndian);\par
682     {\cf18 int} indexOfSoundDataChunk = getIndexOfChunk (fileData, {\cf22 "SSND"}, 12, Endianness::BigEndian);\par
683     {\cf18 int} indexOfXMLChunk = getIndexOfChunk (fileData, {\cf22 "iXML"}, 12, Endianness::BigEndian);\par
684     \par
685     {\cf20 // if we can't find the data or format chunks, or the IDs/formats don't seem to be as expected}\par
686     {\cf20 // then it is unlikely we'll able to read this file, so abort}\par
687     {\cf19 if} (indexOfSoundDataChunk == -1 || indexOfCommChunk == -1 || headerChunkID != {\cf22 "FORM"} || audioFormat == AIFFAudioFormat::Error)\par
688     \{\par
689         reportError ({\cf22 "ERROR: this doesn't seem to be a valid AIFF file"});\par
690         {\cf19 return} {\cf17 false};\par
691     \}\par
692 \par
693     {\cf20 // -----------------------------------------------------------}\par
694     {\cf20 // COMM CHUNK}\par
695     {\cf18 int} p = indexOfCommChunk;\par
696     std::string commChunkID (fileData.begin() + p, fileData.begin() + p + 4);\par
697     {\cf20 //int32_t commChunkSize = fourBytesToInt (fileData, p + 4, Endianness::BigEndian);}\par
698     int16_t numChannels = twoBytesToInt (fileData, p + 8, Endianness::BigEndian);\par
699     int32_t numSamplesPerChannel = fourBytesToInt (fileData, p + 10, Endianness::BigEndian);\par
700     bitDepth = (int) twoBytesToInt (fileData, p + 14, Endianness::BigEndian);\par
701     sampleRate = getAiffSampleRate (fileData, p + 16);\par
702     \par
703     {\cf20 // check the sample rate was properly decoded}\par
704     {\cf19 if} (sampleRate == 0)\par
705     \{\par
706         reportError ({\cf22 "ERROR: this AIFF file has an unsupported sample rate"});\par
707         {\cf19 return} {\cf17 false};\par
708     \}\par
709     \par
710     {\cf20 // check the number of channels is mono or stereo}\par
711     {\cf19 if} (numChannels < 1 ||numChannels > 2)\par
712     \{\par
713         reportError ({\cf22 "ERROR: this AIFF file seems to be neither mono nor stereo (perhaps multi-track, or corrupted?)"});\par
714         {\cf19 return} {\cf17 false};\par
715     \}\par
716     \par
717     {\cf20 // check bit depth is either 8, 16, 24 or 32-bit}\par
718     {\cf19 if} (bitDepth != 8 && bitDepth != 16 && bitDepth != 24 && bitDepth != 32)\par
719     \{\par
720         reportError ({\cf22 "ERROR: this file has a bit depth that is not 8, 16, 24 or 32 bits"});\par
721         {\cf19 return} {\cf17 false};\par
722     \}\par
723     \par
724     {\cf20 // -----------------------------------------------------------}\par
725     {\cf20 // SSND CHUNK}\par
726     {\cf18 int} s = indexOfSoundDataChunk;\par
727     std::string soundDataChunkID (fileData.begin() + s, fileData.begin() + s + 4);\par
728     int32_t soundDataChunkSize = fourBytesToInt (fileData, s + 4, Endianness::BigEndian);\par
729     int32_t offset = fourBytesToInt (fileData, s + 8, Endianness::BigEndian);\par
730     {\cf20 //int32_t blockSize = fourBytesToInt (fileData, s + 12, Endianness::BigEndian);}\par
731     \par
732     {\cf18 int} numBytesPerSample = bitDepth / 8;\par
733     {\cf18 int} numBytesPerFrame = numBytesPerSample * numChannels;\par
734     {\cf18 int} totalNumAudioSampleBytes = numSamplesPerChannel * numBytesPerFrame;\par
735     {\cf18 int} samplesStartIndex = s + 16 + (int)offset;\par
736         \par
737     {\cf20 // sanity check the data}\par
738     {\cf19 if} ((soundDataChunkSize - 8) != totalNumAudioSampleBytes || totalNumAudioSampleBytes > {\cf17 static_cast<}{\cf18 long}{\cf17 >}(fileData.size() - samplesStartIndex))\par
739     \{\par
740         reportError ({\cf22 "ERROR: the metadatafor this file doesn't seem right"});\par
741         {\cf19 return} {\cf17 false};\par
742     \}\par
743     \par
744     clearAudioBuffer();\par
745     samples.resize (numChannels);\par
746     \par
747     {\cf19 for} ({\cf18 int} i = 0; i < numSamplesPerChannel; i++)\par
748     \{\par
749         {\cf19 for} ({\cf18 int} channel = 0; channel < numChannels; channel++)\par
750         \{\par
751             {\cf18 int} sampleIndex = samplesStartIndex + (numBytesPerFrame * i) + channel * numBytesPerSample;\par
752             \par
753             {\cf19 if} ((sampleIndex + (bitDepth / 8) - 1) >= fileData.size())\par
754             \{\par
755                 reportError ({\cf22 "ERROR: read file error as the metadata indicates more samples than there are in the file data"});\par
756                 {\cf19 return} {\cf17 false};\par
757             \}\par
758             \par
759             {\cf19 if} (bitDepth == 8)\par
760             \{\par
761                 int8_t sampleAsSigned8Bit = (int8_t)fileData[sampleIndex];\par
762                 T sample = (T)sampleAsSigned8Bit / (T)128.;\par
763                 samples[channel].push_back (sample);\par
764             \}\par
765             {\cf19 else} {\cf19 if} (bitDepth == 16)\par
766             \{\par
767                 int16_t sampleAsInt = twoBytesToInt (fileData, sampleIndex, Endianness::BigEndian);\par
768                 T sample = sixteenBitIntToSample (sampleAsInt);\par
769                 samples[channel].push_back (sample);\par
770             \}\par
771             {\cf19 else} {\cf19 if} (bitDepth == 24)\par
772             \{\par
773                 int32_t sampleAsInt = 0;\par
774                 sampleAsInt = (fileData[sampleIndex] << 16) | (fileData[sampleIndex + 1] << 8) | fileData[sampleIndex + 2];\par
775                 \par
776                 {\cf19 if} (sampleAsInt & 0x800000) {\cf20 //  if the 24th bit is set, this is a negative number in 24-bit world}\par
777                     sampleAsInt = sampleAsInt | ~0xFFFFFF; {\cf20 // so make sure sign is extended to the 32 bit float}\par
778                 \par
779                 T sample = (T)sampleAsInt / (T)8388608.;\par
780                 samples[channel].push_back (sample);\par
781             \}\par
782             {\cf19 else} {\cf19 if} (bitDepth == 32)\par
783             \{\par
784                 int32_t sampleAsInt = fourBytesToInt (fileData, sampleIndex, Endianness::BigEndian);\par
785                 T sample;\par
786                 \par
787                 {\cf19 if} (audioFormat == AIFFAudioFormat::Compressed)\par
788                     sample = (T){\cf17 reinterpret_cast<}{\cf18 float}&{\cf17 >} (sampleAsInt);\par
789                 {\cf19 else} {\cf20 // assume uncompressed}\par
790                     sample = (T) sampleAsInt / {\cf17 static_cast<}{\cf18 float}{\cf17 >} (std::numeric_limits<std::int32_t>::max());\par
791                     \par
792                 samples[channel].push_back (sample);\par
793             \}\par
794             {\cf19 else}\par
795             \{\par
796                 assert ({\cf17 false});\par
797             \}\par
798         \}\par
799     \}\par
800 \par
801     {\cf20 // -----------------------------------------------------------}\par
802     {\cf20 // iXML CHUNK}\par
803     {\cf19 if} (indexOfXMLChunk != -1)\par
804     \{\par
805         int32_t chunkSize = fourBytesToInt (fileData, indexOfXMLChunk + 4);\par
806         iXMLChunk = std::string (({\cf17 const} {\cf18 char}*) &fileData[indexOfXMLChunk + 8], chunkSize);\par
807     \}\par
808     \par
809     {\cf19 return} {\cf17 true};\par
810 \}\par
811 \par
812 {\cf20 //=============================================================}\par
813 {\cf17 template} <{\cf17 class} T>\par
814 uint32_t AudioFile<T>::getAiffSampleRate (std::vector<uint8_t>& fileData, {\cf18 int} sampleRateStartIndex)\par
815 \{\par
816     {\cf19 for} ({\cf17 auto} it : aiffSampleRateTable)\par
817     \{\par
818         {\cf19 if} (tenByteMatch (fileData, sampleRateStartIndex, it.second, 0))\par
819             {\cf19 return} it.first;\par
820     \}\par
821     \par
822     {\cf19 return} 0;\par
823 \}\par
824 \par
825 {\cf20 //=============================================================}\par
826 {\cf17 template} <{\cf17 class} T>\par
827 {\cf18 bool} AudioFile<T>::tenByteMatch (std::vector<uint8_t>& v1, {\cf18 int} startIndex1, std::vector<uint8_t>& v2, {\cf18 int} startIndex2)\par
828 \{\par
829     {\cf19 for} ({\cf18 int} i = 0; i < 10; i++)\par
830     \{\par
831         {\cf19 if} (v1[startIndex1 + i] != v2[startIndex2 + i])\par
832             {\cf19 return} {\cf17 false};\par
833     \}\par
834     \par
835     {\cf19 return} {\cf17 true};\par
836 \}\par
837 \par
838 {\cf20 //=============================================================}\par
839 {\cf17 template} <{\cf17 class} T>\par
840 {\cf18 void} AudioFile<T>::addSampleRateToAiffData (std::vector<uint8_t>& fileData, uint32_t sampleRate)\par
841 \{\par
842     {\cf19 if} (aiffSampleRateTable.count (sampleRate) > 0)\par
843     \{\par
844         {\cf19 for} ({\cf18 int} i = 0; i < 10; i++)\par
845             fileData.push_back (aiffSampleRateTable[sampleRate][i]);\par
846     \}\par
847 \}\par
848 \par
849 {\cf20 //=============================================================}\par
850 {\cf17 template} <{\cf17 class} T>\par
851 {\cf18 bool} AudioFile<T>::save (std::string filePath, AudioFileFormat format)\par
852 \{\par
853     {\cf19 if} (format == AudioFileFormat::Wave)\par
854     \{\par
855         {\cf19 return} saveToWaveFile (filePath);\par
856     \}\par
857     {\cf19 else} {\cf19 if} (format == AudioFileFormat::Aiff)\par
858     \{\par
859         {\cf19 return} saveToAiffFile (filePath);\par
860     \}\par
861     \par
862     {\cf19 return} {\cf17 false};\par
863 \}\par
864 \par
865 {\cf20 //=============================================================}\par
866 {\cf17 template} <{\cf17 class} T>\par
867 {\cf18 bool} AudioFile<T>::saveToWaveFile (std::string filePath)\par
868 \{\par
869     std::vector<uint8_t> fileData;\par
870     \par
871     int32_t dataChunkSize = getNumSamplesPerChannel() * (getNumChannels() * bitDepth / 8);\par
872     int16_t audioFormat = bitDepth == 32 ? WavAudioFormat::IEEEFloat : WavAudioFormat::PCM;\par
873     int32_t formatChunkSize = audioFormat == WavAudioFormat::PCM ? 16 : 18;\par
874     int32_t iXMLChunkSize = {\cf17 static_cast<}int32_t{\cf17 >} (iXMLChunk.size());\par
875     \par
876     {\cf20 // -----------------------------------------------------------}\par
877     {\cf20 // HEADER CHUNK}\par
878     addStringToFileData (fileData, {\cf22 "RIFF"});\par
879     \par
880     {\cf20 // The file size in bytes is the header chunk size (4, not counting RIFF and WAVE) + the format}\par
881     {\cf20 // chunk size (24) + the metadata part of the data chunk plus the actual data chunk size}\par
882     int32_t fileSizeInBytes = 4 + formatChunkSize + 8 + 8 + dataChunkSize;\par
883     {\cf19 if} (iXMLChunkSize > 0)\par
884     \{\par
885         fileSizeInBytes += (8 + iXMLChunkSize);\par
886     \}\par
887 \par
888     addInt32ToFileData (fileData, fileSizeInBytes);\par
889     \par
890     addStringToFileData (fileData, {\cf22 "WAVE"});\par
891     \par
892     {\cf20 // -----------------------------------------------------------}\par
893     {\cf20 // FORMAT CHUNK}\par
894     addStringToFileData (fileData, {\cf22 "fmt "});\par
895     addInt32ToFileData (fileData, formatChunkSize); {\cf20 // format chunk size (16 for PCM)}\par
896     addInt16ToFileData (fileData, audioFormat); {\cf20 // audio format}\par
897     addInt16ToFileData (fileData, (int16_t)getNumChannels()); {\cf20 // num channels}\par
898     addInt32ToFileData (fileData, (int32_t)sampleRate); {\cf20 // sample rate}\par
899     \par
900     int32_t numBytesPerSecond = (int32_t) ((getNumChannels() * sampleRate * bitDepth) / 8);\par
901     addInt32ToFileData (fileData, numBytesPerSecond);\par
902     \par
903     int16_t numBytesPerBlock = getNumChannels() * (bitDepth / 8);\par
904     addInt16ToFileData (fileData, numBytesPerBlock);\par
905     \par
906     addInt16ToFileData (fileData, (int16_t)bitDepth);\par
907     \par
908     {\cf19 if} (audioFormat == WavAudioFormat::IEEEFloat)\par
909         addInt16ToFileData (fileData, 0); {\cf20 // extension size}\par
910     \par
911     {\cf20 // -----------------------------------------------------------}\par
912     {\cf20 // DATA CHUNK}\par
913     addStringToFileData (fileData, {\cf22 "data"});\par
914     addInt32ToFileData (fileData, dataChunkSize);\par
915     \par
916     {\cf19 for} ({\cf18 int} i = 0; i < getNumSamplesPerChannel(); i++)\par
917     \{\par
918         {\cf19 for} ({\cf18 int} channel = 0; channel < getNumChannels(); channel++)\par
919         \{\par
920             {\cf19 if} (bitDepth == 8)\par
921             \{\par
922                 uint8_t {\cf18 byte} = sampleToSingleByte (samples[channel][i]);\par
923                 fileData.push_back ({\cf18 byte});\par
924             \}\par
925             {\cf19 else} {\cf19 if} (bitDepth == 16)\par
926             \{\par
927                 int16_t sampleAsInt = sampleToSixteenBitInt (samples[channel][i]);\par
928                 addInt16ToFileData (fileData, sampleAsInt);\par
929             \}\par
930             {\cf19 else} {\cf19 if} (bitDepth == 24)\par
931             \{\par
932                 int32_t sampleAsIntAgain = (int32_t) (samples[channel][i] * (T)8388608.);\par
933                 \par
934                 uint8_t bytes[3];\par
935                 bytes[2] = (uint8_t) (sampleAsIntAgain >> 16) & 0xFF;\par
936                 bytes[1] = (uint8_t) (sampleAsIntAgain >>  8) & 0xFF;\par
937                 bytes[0] = (uint8_t) sampleAsIntAgain & 0xFF;\par
938                 \par
939                 fileData.push_back (bytes[0]);\par
940                 fileData.push_back (bytes[1]);\par
941                 fileData.push_back (bytes[2]);\par
942             \}\par
943             {\cf19 else} {\cf19 if} (bitDepth == 32)\par
944             \{\par
945                 int32_t sampleAsInt;\par
946                 \par
947                 {\cf19 if} (audioFormat == WavAudioFormat::IEEEFloat)\par
948                     sampleAsInt = (int32_t) {\cf17 reinterpret_cast<}int32_t&{\cf17 >} (samples[channel][i]);\par
949                 {\cf19 else} {\cf20 // assume PCM}\par
950                     sampleAsInt = (int32_t) (samples[channel][i] * std::numeric_limits<int32_t>::max());\par
951                 \par
952                 addInt32ToFileData (fileData, sampleAsInt, Endianness::LittleEndian);\par
953             \}\par
954             {\cf19 else}\par
955             \{\par
956                 assert ({\cf17 false} && {\cf22 "Trying to write a file with unsupported bit depth"});\par
957                 {\cf19 return} {\cf17 false};\par
958             \}\par
959         \}\par
960     \}\par
961     \par
962     {\cf20 // -----------------------------------------------------------}\par
963     {\cf20 // iXML CHUNK}\par
964     {\cf19 if} (iXMLChunkSize > 0) \par
965     \{\par
966         addStringToFileData (fileData, {\cf22 "iXML"});\par
967         addInt32ToFileData (fileData, iXMLChunkSize);\par
968         addStringToFileData (fileData, iXMLChunk);\par
969     \}\par
970     \par
971     {\cf20 // check that the various sizes we put in the metadata are correct}\par
972     {\cf19 if} (fileSizeInBytes != {\cf17 static_cast<}int32_t{\cf17 >} (fileData.size() - 8) || dataChunkSize != (getNumSamplesPerChannel() * getNumChannels() * (bitDepth / 8)))\par
973     \{\par
974         reportError ({\cf22 "ERROR: couldn't save file to "} + filePath);\par
975         {\cf19 return} {\cf17 false};\par
976     \}\par
977     \par
978     {\cf20 // try to write the file}\par
979     {\cf19 return} writeDataToFile (fileData, filePath);\par
980 \}\par
981 \par
982 {\cf20 //=============================================================}\par
983 {\cf17 template} <{\cf17 class} T>\par
984 {\cf18 bool} AudioFile<T>::saveToAiffFile (std::string filePath)\par
985 \{\par
986     std::vector<uint8_t> fileData;\par
987     \par
988     int32_t numBytesPerSample = bitDepth / 8;\par
989     int32_t numBytesPerFrame = numBytesPerSample * getNumChannels();\par
990     int32_t totalNumAudioSampleBytes = getNumSamplesPerChannel() * numBytesPerFrame;\par
991     int32_t soundDataChunkSize = totalNumAudioSampleBytes + 8;\par
992     int32_t iXMLChunkSize = {\cf17 static_cast<}int32_t{\cf17 >} (iXMLChunk.size());\par
993     \par
994     {\cf20 // -----------------------------------------------------------}\par
995     {\cf20 // HEADER CHUNK}\par
996     addStringToFileData (fileData, {\cf22 "FORM"});\par
997     \par
998     {\cf20 // The file size in bytes is the header chunk size (4, not counting FORM and AIFF) + the COMM}\par
999     {\cf20 // chunk size (26) + the metadata part of the SSND chunk plus the actual data chunk size}\par
1000     int32_t fileSizeInBytes = 4 + 26 + 16 + totalNumAudioSampleBytes;\par
1001     {\cf19 if} (iXMLChunkSize > 0)\par
1002     \{\par
1003         fileSizeInBytes += (8 + iXMLChunkSize);\par
1004     \}\par
1005 \par
1006     addInt32ToFileData (fileData, fileSizeInBytes, Endianness::BigEndian);\par
1007     \par
1008     addStringToFileData (fileData, {\cf22 "AIFF"});\par
1009     \par
1010     {\cf20 // -----------------------------------------------------------}\par
1011     {\cf20 // COMM CHUNK}\par
1012     addStringToFileData (fileData, {\cf22 "COMM"});\par
1013     addInt32ToFileData (fileData, 18, Endianness::BigEndian); {\cf20 // commChunkSize}\par
1014     addInt16ToFileData (fileData, getNumChannels(), Endianness::BigEndian); {\cf20 // num channels}\par
1015     addInt32ToFileData (fileData, getNumSamplesPerChannel(), Endianness::BigEndian); {\cf20 // num samples per channel}\par
1016     addInt16ToFileData (fileData, bitDepth, Endianness::BigEndian); {\cf20 // bit depth}\par
1017     addSampleRateToAiffData (fileData, sampleRate);\par
1018     \par
1019     {\cf20 // -----------------------------------------------------------}\par
1020     {\cf20 // SSND CHUNK}\par
1021     addStringToFileData (fileData, {\cf22 "SSND"});\par
1022     addInt32ToFileData (fileData, soundDataChunkSize, Endianness::BigEndian);\par
1023     addInt32ToFileData (fileData, 0, Endianness::BigEndian); {\cf20 // offset}\par
1024     addInt32ToFileData (fileData, 0, Endianness::BigEndian); {\cf20 // block size}\par
1025     \par
1026     {\cf19 for} ({\cf18 int} i = 0; i < getNumSamplesPerChannel(); i++)\par
1027     \{\par
1028         {\cf19 for} ({\cf18 int} channel = 0; channel < getNumChannels(); channel++)\par
1029         \{\par
1030             {\cf19 if} (bitDepth == 8)\par
1031             \{\par
1032                 uint8_t {\cf18 byte} = sampleToSingleByte (samples[channel][i]);\par
1033                 fileData.push_back ({\cf18 byte});\par
1034             \}\par
1035             {\cf19 else} {\cf19 if} (bitDepth == 16)\par
1036             \{\par
1037                 int16_t sampleAsInt = sampleToSixteenBitInt (samples[channel][i]);\par
1038                 addInt16ToFileData (fileData, sampleAsInt, Endianness::BigEndian);\par
1039             \}\par
1040             {\cf19 else} {\cf19 if} (bitDepth == 24)\par
1041             \{\par
1042                 int32_t sampleAsIntAgain = (int32_t) (samples[channel][i] * (T)8388608.);\par
1043                 \par
1044                 uint8_t bytes[3];\par
1045                 bytes[0] = (uint8_t) (sampleAsIntAgain >> 16) & 0xFF;\par
1046                 bytes[1] = (uint8_t) (sampleAsIntAgain >>  8) & 0xFF;\par
1047                 bytes[2] = (uint8_t) sampleAsIntAgain & 0xFF;\par
1048                 \par
1049                 fileData.push_back (bytes[0]);\par
1050                 fileData.push_back (bytes[1]);\par
1051                 fileData.push_back (bytes[2]);\par
1052             \}\par
1053             {\cf19 else} {\cf19 if} (bitDepth == 32)\par
1054             \{\par
1055                 {\cf20 // write samples as signed integers (no implementation yet for floating point, but looking at WAV implementation should help)}\par
1056                 int32_t sampleAsInt = (int32_t) (samples[channel][i] * std::numeric_limits<int32_t>::max());\par
1057                 addInt32ToFileData (fileData, sampleAsInt, Endianness::BigEndian);\par
1058             \}\par
1059             {\cf19 else}\par
1060             \{\par
1061                 assert ({\cf17 false} && {\cf22 "Trying to write a file with unsupported bit depth"});\par
1062                 {\cf19 return} {\cf17 false};\par
1063             \}\par
1064         \}\par
1065     \}\par
1066 \par
1067     {\cf20 // -----------------------------------------------------------}\par
1068     {\cf20 // iXML CHUNK}\par
1069     {\cf19 if} (iXMLChunkSize > 0)\par
1070     \{\par
1071         addStringToFileData (fileData, {\cf22 "iXML"});\par
1072         addInt32ToFileData (fileData, iXMLChunkSize, Endianness::BigEndian);\par
1073         addStringToFileData (fileData, iXMLChunk);\par
1074     \}\par
1075     \par
1076     {\cf20 // check that the various sizes we put in the metadata are correct}\par
1077     {\cf19 if} (fileSizeInBytes != {\cf17 static_cast<}int32_t{\cf17 >} (fileData.size() - 8) || soundDataChunkSize != getNumSamplesPerChannel() *  numBytesPerFrame + 8)\par
1078     \{\par
1079         reportError ({\cf22 "ERROR: couldn't save file to "} + filePath);\par
1080         {\cf19 return} {\cf17 false};\par
1081     \}\par
1082     \par
1083     {\cf20 // try to write the file}\par
1084     {\cf19 return} writeDataToFile (fileData, filePath);\par
1085 \}\par
1086 \par
1087 {\cf20 //=============================================================}\par
1088 {\cf17 template} <{\cf17 class} T>\par
1089 {\cf18 bool} AudioFile<T>::writeDataToFile (std::vector<uint8_t>& fileData, std::string filePath)\par
1090 \{\par
1091     std::ofstream outputFile (filePath, std::ios::binary);\par
1092     \par
1093     {\cf19 if} (outputFile.is_open())\par
1094     \{\par
1095         {\cf19 for} ({\cf18 size_t} i = 0; i < fileData.size(); i++)\par
1096         \{\par
1097             {\cf18 char} value = (char) fileData[i];\par
1098             outputFile.write (&value, {\cf17 sizeof} ({\cf18 char}));\par
1099         \}\par
1100         \par
1101         outputFile.close();\par
1102         \par
1103         {\cf19 return} {\cf17 true};\par
1104     \}\par
1105     \par
1106     {\cf19 return} {\cf17 false};\par
1107 \}\par
1108 \par
1109 {\cf20 //=============================================================}\par
1110 {\cf17 template} <{\cf17 class} T>\par
1111 {\cf18 void} AudioFile<T>::addStringToFileData (std::vector<uint8_t>& fileData, std::string s)\par
1112 \{\par
1113     {\cf19 for} ({\cf18 size_t} i = 0; i < s.length();i++)\par
1114         fileData.push_back ((uint8_t) s[i]);\par
1115 \}\par
1116 \par
1117 {\cf20 //=============================================================}\par
1118 {\cf17 template} <{\cf17 class} T>\par
1119 {\cf18 void} AudioFile<T>::addInt32ToFileData (std::vector<uint8_t>& fileData, int32_t i, Endianness endianness)\par
1120 \{\par
1121     uint8_t bytes[4];\par
1122     \par
1123     {\cf19 if} (endianness == Endianness::LittleEndian)\par
1124     \{\par
1125         bytes[3] = (i >> 24) & 0xFF;\par
1126         bytes[2] = (i >> 16) & 0xFF;\par
1127         bytes[1] = (i >> 8) & 0xFF;\par
1128         bytes[0] = i & 0xFF;\par
1129     \}\par
1130     {\cf19 else}\par
1131     \{\par
1132         bytes[0] = (i >> 24) & 0xFF;\par
1133         bytes[1] = (i >> 16) & 0xFF;\par
1134         bytes[2] = (i >> 8) & 0xFF;\par
1135         bytes[3] = i & 0xFF;\par
1136     \}\par
1137     \par
1138     {\cf19 for} ({\cf18 int} i = 0; i < 4; i++)\par
1139         fileData.push_back (bytes[i]);\par
1140 \}\par
1141 \par
1142 {\cf20 //=============================================================}\par
1143 {\cf17 template} <{\cf17 class} T>\par
1144 {\cf18 void} AudioFile<T>::addInt16ToFileData (std::vector<uint8_t>& fileData, int16_t i, Endianness endianness)\par
1145 \{\par
1146     uint8_t bytes[2];\par
1147     \par
1148     {\cf19 if} (endianness == Endianness::LittleEndian)\par
1149     \{\par
1150         bytes[1] = (i >> 8) & 0xFF;\par
1151         bytes[0] = i & 0xFF;\par
1152     \}\par
1153     {\cf19 else}\par
1154     \{\par
1155         bytes[0] = (i >> 8) & 0xFF;\par
1156         bytes[1] = i & 0xFF;\par
1157     \}\par
1158     \par
1159     fileData.push_back (bytes[0]);\par
1160     fileData.push_back (bytes[1]);\par
1161 \}\par
1162 \par
1163 {\cf20 //=============================================================}\par
1164 {\cf17 template} <{\cf17 class} T>\par
1165 {\cf18 void} AudioFile<T>::clearAudioBuffer()\par
1166 \{\par
1167     {\cf19 for} ({\cf18 size_t} i = 0; i < samples.size();i++)\par
1168     \{\par
1169         samples[i].clear();\par
1170     \}\par
1171     \par
1172     samples.clear();\par
1173 \}\par
1174 \par
1175 {\cf20 //=============================================================}\par
1176 {\cf17 template} <{\cf17 class} T>\par
1177 AudioFileFormat AudioFile<T>::determineAudioFileFormat (std::vector<uint8_t>& fileData)\par
1178 \{\par
1179     std::string header (fileData.begin(), fileData.begin() + 4);\par
1180     \par
1181     {\cf19 if} (header == {\cf22 "RIFF"})\par
1182         {\cf19 return} AudioFileFormat::Wave;\par
1183     {\cf19 else} {\cf19 if} (header == {\cf22 "FORM"})\par
1184         {\cf19 return} AudioFileFormat::Aiff;\par
1185     {\cf19 else}\par
1186         {\cf19 return} AudioFileFormat::Error;\par
1187 \}\par
1188 \par
1189 {\cf20 //=============================================================}\par
1190 {\cf17 template} <{\cf17 class} T>\par
1191 int32_t AudioFile<T>::fourBytesToInt (std::vector<uint8_t>& source, {\cf18 int} startIndex, Endianness endianness)\par
1192 \{\par
1193     int32_t result;\par
1194     \par
1195     {\cf19 if} (endianness == Endianness::LittleEndian)\par
1196         result = (source[startIndex + 3] << 24) | (source[startIndex + 2] << 16) | (source[startIndex + 1] << 8) | source[startIndex];\par
1197     {\cf19 else}\par
1198         result = (source[startIndex] << 24) | (source[startIndex + 1] << 16) | (source[startIndex + 2] << 8) | source[startIndex + 3];\par
1199     \par
1200     {\cf19 return} result;\par
1201 \}\par
1202 \par
1203 {\cf20 //=============================================================}\par
1204 {\cf17 template} <{\cf17 class} T>\par
1205 int16_t AudioFile<T>::twoBytesToInt (std::vector<uint8_t>& source, {\cf18 int} startIndex, Endianness endianness)\par
1206 \{\par
1207     int16_t result;\par
1208     \par
1209     {\cf19 if} (endianness == Endianness::LittleEndian)\par
1210         result = (source[startIndex + 1] << 8) | source[startIndex];\par
1211     {\cf19 else}\par
1212         result = (source[startIndex] << 8) | source[startIndex + 1];\par
1213     \par
1214     {\cf19 return} result;\par
1215 \}\par
1216 \par
1217 {\cf20 //=============================================================}\par
1218 {\cf17 template} <{\cf17 class} T>\par
1219 {\cf18 int} AudioFile<T>::getIndexOfString (std::vector<uint8_t>& source, std::string stringToSearchFor)\par
1220 \{\par
1221     {\cf18 int} index = -1;\par
1222     {\cf18 int} stringLength = (int)stringToSearchFor.length();\par
1223     \par
1224     {\cf19 for} ({\cf18 size_t} i = 0; i < source.size() - stringLength;i++)\par
1225     \{\par
1226         std::string section (source.begin() + i, source.begin() + i + stringLength);\par
1227         \par
1228         {\cf19 if} (section == stringToSearchFor)\par
1229         \{\par
1230             index = {\cf17 static_cast<}{\cf18 int}{\cf17 >} (i);\par
1231             {\cf19 break};\par
1232         \}\par
1233     \}\par
1234     \par
1235     {\cf19 return} index;\par
1236 \}\par
1237 \par
1238 {\cf20 //=============================================================}\par
1239 {\cf17 template} <{\cf17 class} T>\par
1240 {\cf18 int} AudioFile<T>::getIndexOfChunk (std::vector<uint8_t>& source, {\cf17 const} std::string& chunkHeaderID, {\cf18 int} startIndex, Endianness endianness)\par
1241 \{\par
1242     {\cf17 constexpr} {\cf18 int} dataLen = 4;\par
1243     {\cf19 if} (chunkHeaderID.size() != dataLen)\par
1244     \{\par
1245         assert ({\cf17 false} && {\cf22 "Invalid chunk header ID string"});\par
1246         {\cf19 return} -1;\par
1247     \}\par
1248 \par
1249     {\cf18 int} i = startIndex;\par
1250     {\cf19 while} (i < source.size() - dataLen)\par
1251     \{\par
1252         {\cf19 if} (memcmp (&source[i], chunkHeaderID.data(), dataLen) == 0)\par
1253         \{\par
1254             {\cf19 return} i;\par
1255         \}\par
1256 \par
1257         i += dataLen;\par
1258         {\cf17 auto} chunkSize = fourBytesToInt (source, i, endianness);\par
1259         i += (dataLen + chunkSize);\par
1260     \}\par
1261 \par
1262     {\cf19 return} -1;\par
1263 \}\par
1264 \par
1265 {\cf20 //=============================================================}\par
1266 {\cf17 template} <{\cf17 class} T>\par
1267 T AudioFile<T>::sixteenBitIntToSample (int16_t sample)\par
1268 \{\par
1269     {\cf19 return} {\cf17 static_cast<}T{\cf17 >} (sample) / {\cf17 static_cast<}T{\cf17 >} (32768.);\par
1270 \}\par
1271 \par
1272 {\cf20 //=============================================================}\par
1273 {\cf17 template} <{\cf17 class} T>\par
1274 int16_t AudioFile<T>::sampleToSixteenBitInt (T sample)\par
1275 \{\par
1276     sample = clamp (sample, -1., 1.);\par
1277     {\cf19 return} {\cf17 static_cast<}int16_t{\cf17 >} (sample * 32767.);\par
1278 \}\par
1279 \par
1280 {\cf20 //=============================================================}\par
1281 {\cf17 template} <{\cf17 class} T>\par
1282 uint8_t AudioFile<T>::sampleToSingleByte (T sample)\par
1283 \{\par
1284     sample = clamp (sample, -1., 1.);\par
1285     sample = (sample + 1.) / 2.;\par
1286     {\cf19 return} {\cf17 static_cast<}uint8_t{\cf17 >} (sample * 255.);\par
1287 \}\par
1288 \par
1289 {\cf20 //=============================================================}\par
1290 {\cf17 template} <{\cf17 class} T>\par
1291 T AudioFile<T>::singleByteToSample (uint8_t sample)\par
1292 \{\par
1293     {\cf19 return} {\cf17 static_cast<}T{\cf17 >} (sample - 128) / {\cf17 static_cast<}T{\cf17 >} (128.);\par
1294 \}\par
1295 \par
1296 {\cf20 //=============================================================}\par
1297 {\cf17 template} <{\cf17 class} T>\par
1298 T AudioFile<T>::clamp (T value, T minValue, T maxValue)\par
1299 \{\par
1300     value = std::min (value, maxValue);\par
1301     value = std::max (value, minValue);\par
1302     {\cf19 return} value;\par
1303 \}\par
1304 \par
1305 {\cf20 //=============================================================}\par
1306 {\cf17 template} <{\cf17 class} T>\par
1307 {\cf18 void} AudioFile<T>::reportError (std::string errorMessage)\par
1308 \{\par
1309     {\cf19 if} (logErrorsToConsole)\par
1310         std::cout << errorMessage << std::endl;\par
1311 \}\par
1312 \par
1313 {\cf21 #if defined (_MSC_VER)}\par
1314     __pragma(warning (pop))\par
1315 {\cf21 #elif defined (__GNUC__)}\par
1316     _Pragma({\cf22 "GCC diagnostic pop"})\par
1317 {\cf21 #endif}\par
1318 \par
1319 {\cf21 #endif }{\cf20 /* AudioFile_h */}{\cf21 }\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
correlate.h\par \pard\plain 
{\tc\tcl2 \v correlate/correlate.h}
{\xe \v correlate/correlate.h}
{\bkmkstart AAAAAAAAAB}
{\bkmkend AAAAAAAAAB}
{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 1 {\cf20 //}\par
2 {\cf20 // Created by ross on 08/03/2022.}\par
3 {\cf20 //}\par
4 \par
5 {\cf21 #ifndef CORRELATE_H}\par
6 {\cf21 #define CORRELATE_H}\par
7 {\cf21 #include "AudioFile/AudioFile.h"}\par
8 {\cf21 #include <cmath>}\par
9 \par
10 \par
11 \par
12 {\cf18 double} wcorr_rho(AudioFile<double> x, AudioFile<double> y);\par
13 \par
14 {\cf18 double} wcorr_cov(AudioFile<double> x, AudioFile<double> y);\par
15 \par
16 {\cf18 double} wcorr_stdev(AudioFile<double> signal);\par
17 \par
18 {\cf18 double} wcorr_mean(AudioFile<double> signal);\par
19 \par
20 {\cf18 double} wcorr_rho2snr({\cf18 double} p, {\cf18 bool} as_db);\par
21 \par
22 \par
23 {\cf21 #endif}\par
24 \par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
SignalCleaner.h\par \pard\plain 
{\tc\tcl2 \v SignalCleaner/SignalCleaner.h}
{\xe \v SignalCleaner/SignalCleaner.h}
{\bkmkstart AAAAAAAAAC}
{\bkmkend AAAAAAAAAC}
{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 1 {\cf20 //}\par
2 {\cf20 // Created by ross on 08/03/2022.}\par
3 {\cf20 //}\par
4 \par
5 {\cf21 #ifndef FIR1_SIGNALCLEANER_H}\par
6 {\cf21 #define FIR1_SIGNALCLEANER_H}\par
7 {\cf21 #include <Fir1.h>}\par
8 {\cf21 #include "AudioFile/AudioFile.h"}\par
9 {\cf21 #include <cmath>}\par
10 \par
11 \par
12 {\cf17 class }SignalCleaner \{\par
13 {\cf17 public}:\par
14     AudioFile<double> noisey_signal;\par
15     AudioFile<double> noise_source;\par
16     AudioFile<double> output;\par
17     AudioFile<double> clean;\par
18 \par
19     SignalCleaner(std::string noisey_signal_path, std::string noise_source_path, {\cf18 unsigned} nr_taps, {\cf18 double} learning_rate);\par
20 \par
21     {\cf18 bool} SaveFiltered(std::string);\par
22 \par
23     {\cf18 void} Filter();\par
24 \par
25     {\cf18 void} PrintSummaries();\par
26 \par
27 \par
28 {\cf17 private}:\par
29     Fir1 internal_fir;\par
30 \par
31     {\cf18 bool} FileExists(std::string filename);\par
32 \};\par
33 \par
34 \par
35 {\cf21 #endif }{\cf20 //FIR1_SIGNALCLEANER_H}\par
}

\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid Index\par 
\pard\plain 
{\tc \v Index}
{\field\fldedit {\*\fldinst INDEX \\c2 \\*MERGEFORMAT}{\fldrslt INDEX}}
}
