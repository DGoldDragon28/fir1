{\rtf1\ansi\ansicpg1252\uc1 \deff0\deflang1033\deflangfe1033
{\fonttbl {\f0\froman\fcharset0\fprq2{\*\panose 02020603050405020304}Times New Roman;}
{\f1\fswiss\fcharset0\fprq2{\*\panose 020b0604020202020204}Arial;}
{\f2\fmodern\fcharset0\fprq1{\*\panose 02070309020205020404}Courier New;}
{\f3\froman\fcharset2\fprq2{\*\panose 05050102010706020507}Symbol;}
}
{\colortbl;\red0\green0\blue0;\red0\green0\blue255;\red0\green255\blue255;\red0\green255\blue0;\red255\green0\blue255;\red255\green0\blue0;\red255\green255\blue0;\red255\green255\blue255;\red0\green0\blue128;\red0\green128\blue128;\red0\green128\blue0;\red128\green0\blue128;\red128\green0\blue0;\red128\green128\blue0;\red128\green128\blue128;\red192\green192\blue192;\red0\green128\blue0;\red96\green64\blue32;\rede0\green128\blue0;\red128\green0\blue0;\red128\green96\blue32;\red0\green32\blue128;\red0\green128\blue128;\red255\green0\blue255;\red0\green0\blue0;\red112\green0\blue112;\red255\green0\blue0;}
{\stylesheet
{\widctlpar\adjustright \fs20\cgrid \snext0 Normal;}
{\paperw11900\paperh16840\margl1800\margr1800\margt1440\margb1440\gutter0\ltrsect}
{\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid \sbasedon0 \snext0 heading 1;}
{\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid \sbasedon0 \snext0 heading 2;}
{\s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid \sbasedon0 \snext0 heading 3;}
{\s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid \sbasedon0 \snext0 heading 4;}{\*\cs10 \additive Default Paragraph Font;}
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid \sbasedon0 \snext0 heading 5;}{\*\cs10 \additive Default Paragraph Font;}
{\s15\qc\sb240\sa60\widctlpar\outlinelevel0\adjustright \b\f1\fs32\kerning28\cgrid \sbasedon0 \snext15 Title;}
{\s16\qc\sa60\widctlpar\outlinelevel1\adjustright \f1\cgrid \sbasedon0 \snext16 Subtitle;}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid \sbasedon0 \snext17 BodyText;}
{\s18\widctlpar\fs22\cgrid \sbasedon0 \snext18 DenseText;}
{\s28\widctlpar\tqc\tx4320\tqr\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext28 header;}
{\s29\widctlpar\tqc\tx4320\tqr\tx8640\qr\adjustright \fs20\cgrid \sbasedon0 \snext29 footer;}
{\s30\li360\sa60\sb120\keepn\widctlpar\adjustright \b\f1\fs20\cgrid \sbasedon0 \snext30 GroupHeader;}
{\s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext41 Code Example 0;}
{\s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext42 Code Example 1;}
{\s42\li720\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext43 Code Example 2;}
{\s43\li1080\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext44 Code Example 3;}
{\s44\li1440\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext45 Code Example 4;}
{\s45\li1800\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext46 Code Example 5;}
{\s46\li2160\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext47 Code Example 6;}
{\s47\li2520\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext48 Code Example 7;}
{\s48\li2880\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext49 Code Example 8;}
{\s49\li3240\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext50 Code Example 9;}
{\s50\li3600\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext51 Code Example 10;}
{\s51\li3960\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext52 Code Example 11;}
{\s52\li4320\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext53 Code Example 12;}
{\s53\li4680\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext53 Code Example 13;}
{\s60\li0\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext61 List Continue 0;}
{\s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext62 List Continue 1;}
{\s62\li720\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext63 List Continue 2;}
{\s63\li1080\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext64 List Continue 3;}
{\s64\li1440\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext65 List Continue 4;}
{\s65\li1800\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext66 List Continue 5;}
{\s66\li2160\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext67 List Continue 6;}
{\s67\li2520\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext68 List Continue 7;}
{\s68\li2880\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext69 List Continue 8;}
{\s69\li3240\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext70 List Continue 9;}
{\s70\li3600\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext71 List Continue 10;}
{\s71\li3960\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext72 List Continue 11;}
{\s72\li4320\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext73 List Continue 12;}
{\s73\li4680\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext73 List Continue 13;}
{\s80\li0\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext81 DescContinue 0;}
{\s81\li360\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext82 DescContinue 1;}
{\s82\li720\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext83 DescContinue 2;}
{\s83\li1080\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext84 DescContinue 3;}
{\s84\li1440\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext85 DescContinue 4;}
{\s85\li1800\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext86 DescContinue 5;}
{\s86\li2160\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext87 DescContinue 6;}
{\s87\li2520\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext88 DescContinue 7;}
{\s88\li2880\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext89 DescContinue 8;}
{\s89\li3240\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext90 DescContinue 9;}
{\s90\li3600\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext91 DescContinue 10;}
{\s91\li3960\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext92 DescContinue 11;}
{\s92\li4320\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext93 DescContinue 12;}
{\s93\li4680\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext93 DescContinue 13;}
{\s100\li0\sa30\sb30\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext101 LatexTOC 0;}
{\s101\li360\sa27\sb27\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext102 LatexTOC 1;}
{\s102\li720\sa24\sb24\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext103 LatexTOC 2;}
{\s103\li1080\sa21\sb21\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext104 LatexTOC 3;}
{\s104\li1440\sa18\sb18\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext105 LatexTOC 4;}
{\s105\li1800\sa15\sb15\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext106 LatexTOC 5;}
{\s106\li2160\sa12\sb12\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext107 LatexTOC 6;}
{\s107\li2520\sa9\sb9\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext108 LatexTOC 7;}
{\s108\li2880\sa6\sb6\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext109 LatexTOC 8;}
{\s109\li3240\sa3\sb3\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext110 LatexTOC 9;}
{\s110\li3600\sa3\sb3\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext111 LatexTOC 10;}
{\s111\li3960\sa3\sb3\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext112 LatexTOC 11;}
{\s112\li4320\sa3\sb3\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext113 LatexTOC 12;}
{\s113\li4680\sa3\sb3\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext113 LatexTOC 13;}
{\s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext121 \sautoupd List Bullet 0;}
{\s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext122 \sautoupd List Bullet 1;}
{\s122\fi-360\li1080\widctlpar\jclisttab\tx1080{\*\pn \pnlvlbody\ilvl0\ls3\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext123 \sautoupd List Bullet 2;}
{\s123\fi-360\li1440\widctlpar\jclisttab\tx1440{\*\pn \pnlvlbody\ilvl0\ls4\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext124 \sautoupd List Bullet 3;}
{\s124\fi-360\li1800\widctlpar\jclisttab\tx1800{\*\pn \pnlvlbody\ilvl0\ls5\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext125 \sautoupd List Bullet 4;}
{\s125\fi-360\li2160\widctlpar\jclisttab\tx2160{\*\pn \pnlvlbody\ilvl0\ls6\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext126 \sautoupd List Bullet 5;}
{\s126\fi-360\li2520\widctlpar\jclisttab\tx2520{\*\pn \pnlvlbody\ilvl0\ls7\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext127 \sautoupd List Bullet 6;}
{\s127\fi-360\li2880\widctlpar\jclisttab\tx2880{\*\pn \pnlvlbody\ilvl0\ls8\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext128 \sautoupd List Bullet 7;}
{\s128\fi-360\li3240\widctlpar\jclisttab\tx3240{\*\pn \pnlvlbody\ilvl0\ls9\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext129 \sautoupd List Bullet 8;}
{\s129\fi-360\li3600\widctlpar\jclisttab\tx3600{\*\pn \pnlvlbody\ilvl0\ls10\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext130 \sautoupd List Bullet 9;}
{\s130\fi-360\li3960\widctlpar\jclisttab\tx3960{\*\pn \pnlvlbody\ilvl0\ls11\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext131 \sautoupd List Bullet 10;}
{\s131\fi-360\li4320\widctlpar\jclisttab\tx4320{\*\pn \pnlvlbody\ilvl0\ls12\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext132 \sautoupd List Bullet 11;}
{\s132\fi-360\li4680\widctlpar\jclisttab\tx4680{\*\pn \pnlvlbody\ilvl0\ls13\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext133 \sautoupd List Bullet 12;}
{\s133\fi-360\li5040\widctlpar\jclisttab\tx5040{\*\pn \pnlvlbody\ilvl0\ls14\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext133 \sautoupd List Bullet 13;}
{\s140\fi-360\li360\widctlpar\fs20\cgrid \sbasedon0 \snext141 \sautoupd List Enum 0;}
{\s141\fi-360\li720\widctlpar\fs20\cgrid \sbasedon0 \snext142 \sautoupd List Enum 1;}
{\s142\fi-360\li1080\widctlpar\fs20\cgrid \sbasedon0 \snext143 \sautoupd List Enum 2;}
{\s143\fi-360\li1440\widctlpar\fs20\cgrid \sbasedon0 \snext144 \sautoupd List Enum 3;}
{\s144\fi-360\li1800\widctlpar\fs20\cgrid \sbasedon0 \snext145 \sautoupd List Enum 4;}
{\s145\fi-360\li2160\widctlpar\fs20\cgrid \sbasedon0 \snext146 \sautoupd List Enum 5;}
{\s146\fi-360\li2520\widctlpar\fs20\cgrid \sbasedon0 \snext147 \sautoupd List Enum 6;}
{\s147\fi-360\li2880\widctlpar\fs20\cgrid \sbasedon0 \snext148 \sautoupd List Enum 7;}
{\s148\fi-360\li3240\widctlpar\fs20\cgrid \sbasedon0 \snext149 \sautoupd List Enum 8;}
{\s149\fi-360\li3600\widctlpar\fs20\cgrid \sbasedon0 \snext150 \sautoupd List Enum 9;}
{\s150\fi-360\li3960\widctlpar\fs20\cgrid \sbasedon0 \snext151 \sautoupd List Enum 10;}
{\s151\fi-360\li4320\widctlpar\fs20\cgrid \sbasedon0 \snext152 \sautoupd List Enum 11;}
{\s152\fi-360\li4680\widctlpar\fs20\cgrid \sbasedon0 \snext153 \sautoupd List Enum 12;}
{\s153\fi-360\li5040\widctlpar\fs20\cgrid \sbasedon0 \snext153 \sautoupd List Enum 13;}
}
{\info 
{\title {\comment fir1 }fir1}
{\comment Generated by doxygen1.9.3.}
{\creatim \yr2022\mo4\dy1\hr11\min43\sec33}
}\pard\plain 
\sectd\pgnlcrm
{\footer \s29\widctlpar\tqc\tx4320\tqr\tx8640\qr\adjustright \fs20\cgrid {\chpgn}}
\pard\plain \s16\qc\sa60\widctlpar\outlinelevel1\adjustright \f1\cgrid 
\vertalc\qc\par\par\par\par\par\par\par
\pard\plain \s15\qc\sb240\sa60\widctlpar\outlinelevel0\adjustright \b\f1\fs32\kerning28\cgrid 
{\field\fldedit {\*\fldinst TITLE \\*MERGEFORMAT}{\fldrslt fir1}}\par
\pard\plain \s16\qc\sa60\widctlpar\outlinelevel1\adjustright \f1\cgrid 
\par
\par\par\par\par\par\par\par\par\par\par\par\par
\pard\plain \s16\qc\sa60\widctlpar\outlinelevel1\adjustright \f1\cgrid 
{\field\fldedit {\*\fldinst AUTHOR \\*MERGEFORMAT}{\fldrslt AUTHOR}}\par
Version \par{\field\fldedit {\*\fldinst CREATEDATE \\*MERGEFORMAT}{\fldrslt Fri Apr 1 2022 }}\par
\page\page\vertalt
\pard\plain 
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid Table of Contents\par
\pard\plain \par
{\field\fldedit {\*\fldinst TOC \\f \\*MERGEFORMAT}{\fldrslt Table of contents}}\par
\pard\plain 
\sect \sbkpage \pgndec \pgnrestart
\sect \sectd \sbknone
{\footer \s29\widctlpar\tqc\tx4320\tqr\tx8640\qr\adjustright \fs20\cgrid {\chpgn}}

\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
FIR1{\tc \v FIR1}\par \pard\plain 
{\bkmkstart AAAAAAAAEW}
{\bkmkend AAAAAAAAEW}
\par \pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{\bkmkstart AAAAAAAAAH}
{\bkmkend AAAAAAAAAH}
{{\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Documentation
\par}
{\tc\tcl2 \v Documentation}
Take a look at the documentation, {\f2 here}.\par
An efficient finite impulse response (FIR) filter class in C++, JAVA wrapper for Android and Python wrapper.\par
The floating point class offers also adaptive filtering using the least mean square (LMS) or normalised least mean square (NLMS) algorithm.\par}
{\bkmkstart AAAAAAAAAI}
{\bkmkend AAAAAAAAAI}
{{\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Installation
\par}
{\tc\tcl2 \v Installation}
{\bkmkstart AAAAAAAAAJ}
{\bkmkend AAAAAAAAAJ}
{{\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Ubuntu packages for xenial, bionic and focal
\par}
{\tc\tcl3 \v Ubuntu packages for xenial, bionic and focal}
Add this repository to your package manager: {
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid sudo add-apt-repository ppa:berndporr/dsp\par
sudo apt-get update\par
sudo apt install fir1\par
sudo apt install fir1-dev\par
}
 This adds {\f2 fir1-dev}  and {\f2 fir1}  to your package list. The demo files are in {\f2 /usr/share/doc/fir1-dev} . Copy them into a working directory, type {\f2 gunzip *.gz} , {\f2 cmake .}  and {\f2 make} .\par}
{\bkmkstart AAAAAAAAAK}
{\bkmkend AAAAAAAAAK}
{{\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
MacOS packages (homebrew)
\par}
{\tc\tcl3 \v MacOS packages (homebrew)}
Make sure you have the homebrew package manager installed: {\f2 https://brew.sh/}\par
Add the homebrew tap:\par
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid brew tap berndporr/dsp\par
}
\par
and then install the fir filter package with:\par
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid brew install fir\par
}
\par}
{\bkmkstart AAAAAAAAAL}
{\bkmkend AAAAAAAAAL}
{{\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Linux / Unix / MACOSX: compilation from source
\par}
{\tc\tcl3 \v Linux / Unix / MACOSX: compilation from source}
The build system is {\f2 cmake} . Install the library with the standard sequence: {
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid cmake .\par
make\par
sudo make install\par
sudo ldconfig\par
}
 or for debugging run cmake with: {
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid By default optimised release libraries are generated.\par
\par
### Windows\par
\par
Under windows only the static library is generated which\par
should be used for your code development.\par
}
 cmake -G "Visual Studio 16 2019" -A x64 . {
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid and then start Visual C++ and compile it. Usually\par
you want to compile both the release and debug\par
libraries because they are not compatible to each\par
other under Windows.\par
\par
### Android / JAVA\par
\par
The subdirectory `firj` contains an Android project. Load\par
it into Android studio and build it either as a release\par
or debug binary. This generates an Android aar which you\par
import into your project. See the `InstrumentedTest.java`\par
for an instructional example.\par
\par
The pre-compiled libraries are here:\par
```Firj/firj/build/outputs/aar/firj-*.aar\par
}
\par}
{\bkmkstart AAAAAAAAAM}
{\bkmkend AAAAAAAAAM}
{{\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Python
\par}
{\tc\tcl3 \v Python}
{\bkmkstart AAAAAAAAAN}
{\bkmkend AAAAAAAAAN}
{{\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Installation from the python package index (PyPi)
\par}
{\tc\tcl4 \v Installation from the python package index (PyPi)}
Windows / Linux / Mac {
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid pip3 install fir1\par
}
 under Windows it might be just {\f2 pip}  for python3.\par}
{\bkmkstart AAAAAAAAAO}
{\bkmkend AAAAAAAAAO}
{{\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Installation from source
\par}
{\tc\tcl4 \v Installation from source}
Windows / Linux / Mac: make sure that you have swig and a C++ compiler installed. Then type: {
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid python3 setup.py install\par
}
\par}
\par}
\par}
{\bkmkstart AAAAAAAAAP}
{\bkmkend AAAAAAAAAP}
{{\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
How to use it
\par}
{\tc\tcl2 \v How to use it}
{\bkmkstart AAAAAAAAAQ}
{\bkmkend AAAAAAAAAQ}
{{\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
cmake
\par}
{\tc\tcl3 \v cmake}
Add to your {\f2 CMakeLists.txt}  either\par
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid target_link_libraries(myexecutable fir)\par
}
 for the dynamic library or\par
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid target_link_libraries(myexecutable fir_static)\par
}
 for the statically linked library.\par
You can also use {\f2 find_package(fir)} .\par}
{\bkmkstart AAAAAAAAAR}
{\bkmkend AAAAAAAAAR}
{{\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Generating the FIR filter coefficients
\par}
{\tc\tcl3 \v Generating the FIR filter coefficients}
Set the coefficients either with a C floating point array or with a text file containing the coefficients. The text file or the floating point array with the coefficients can easily be generated by Python or OCTAVE/MATLAB:\par
{\bkmkstart AAAAAAAAAS}
{\bkmkend AAAAAAAAAS}
{{\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Python
\par}
{\tc\tcl4 \v Python}
Use the {\f2 firwin}  command to generate the coefficients: {
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid # Sampling rate\par
fs = 1000\par
# bandstop between 45 and 55 Hz:\par
f1 = 45\par
f2 = 55\par
b = signal.firwin(999,[f1/fs*2,f2/fs*2])\par
}
 For fixed point you need to scale up the coefficients, for example by 15 bits: b*32768.\par}
{\bkmkstart AAAAAAAAAT}
{\bkmkend AAAAAAAAAT}
{{\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
octave/MATLAB:
\par}
{\tc\tcl4 \v octave/MATLAB:}
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid octave:1> h=fir1(100,0.1);\par
}
 which creates the coefficients of a lowpass filter with 100 taps and normalised cutoff 0.1 to Nyquist.\par
Again, for fixed point "h" needs to be scaled.\par}
\par}
{\bkmkstart AAAAAAAAAU}
{\bkmkend AAAAAAAAAU}
{{\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Initialisation
\par}
{\tc\tcl3 \v Initialisation}
{\bkmkstart AAAAAAAAAV}
{\bkmkend AAAAAAAAAV}
{{\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
C++ floating point FIR filter:
\par}
{\tc\tcl4 \v C++ floating point FIR filter:}
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid Fir1 fir("h.dat");\par
}
 or import the coefficients as a const double array: {
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid Fir1 fir(coefficients)\par
}
 there is also an option to import a non-const array (for example generated with the ifft) and using std::vector.\par}
{\bkmkstart AAAAAAAAAW}
{\bkmkend AAAAAAAAAW}
{{\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
C++ integer FIR filter:
\par}
{\tc\tcl4 \v C++ integer FIR filter:}
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid Fir1fixed fir("h_fixed.dat",12);\par
}
 where the coefficients have been scaled up by 2^12 and the filter will scale them down by this amount (with the help of a bitshift operation).\par}
{\bkmkstart AAAAAAAAAX}
{\bkmkend AAAAAAAAAX}
{{\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
JAVA:
\par}
{\tc\tcl4 \v JAVA:}
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid Fir1 fir = new Fir1(coeff);\par
}
 where {\f2 coeff}  is an array of double precision coefficients and returns the fir filter class.\par}
{\bkmkstart AAAAAAAAAY}
{\bkmkend AAAAAAAAAY}
{{\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Python
\par}
{\tc\tcl4 \v Python}
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid f = fir1.Fir1(coeff)\par
}
\par}
\par}
{\bkmkstart AAAAAAAAAZ}
{\bkmkend AAAAAAAAAZ}
{{\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Realtime filtering
\par}
{\tc\tcl3 \v Realtime filtering}
{\bkmkstart AAAAAAAABA}
{\bkmkend AAAAAAAABA}
{{\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
C++ double:
\par}
{\tc\tcl4 \v C++ double:}
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid double b = fir.filter(a);\par
}
\par}
{\bkmkstart AAAAAAAABB}
{\bkmkend AAAAAAAABB}
{{\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
C++ integer:
\par}
{\tc\tcl4 \v C++ integer:}
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid int b = fir.filter(a);\par
}
\par}
{\bkmkstart AAAAAAAABC}
{\bkmkend AAAAAAAABC}
{{\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
JAVA:
\par}
{\tc\tcl4 \v JAVA:}
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid double b = fir.filter(a)\par
}
\par}
{\bkmkstart AAAAAAAABD}
{\bkmkend AAAAAAAABD}
{{\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Python
\par}
{\tc\tcl4 \v Python}
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid b = f.filter(a)\par
}
 \par}
\par}
{\bkmkstart AAAAAAAABE}
{\bkmkend AAAAAAAABE}
{{\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Utility methods
\par}
{\tc\tcl3 \v Utility methods}
These functions are the same in C++, JAVA and Python:\par
{
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\f2 getTaps()}  returns the length of the FIR filter kernel.\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\f2 reset()}  sets all delay lines to zero.\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\f2 zeroCoeff()}  sets all coefficients to zero.\par}
\par
Retreiving the coefficients/kernel from the FIR filter is different depending on the language used:\par
{\bkmkstart AAAAAAAABF}
{\bkmkend AAAAAAAABF}
{{\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
C++
\par}
{\tc\tcl4 \v C++}
{
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\f2 void getCoeff(double* target, unsigned length) const}  copies the FIR kernel into the given C array of {\f2 double} s with length {\f2 length} .\par
If {\f2 length}  exceeds the length of the filter kernel, the result is zero-padded to fill the given array.\par
If {\f2 length}  is smaller than the filter kernel, a {\f2 std::out_of_range}  exception is thrown.\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\f2 std::vector<double> getCoeffVector() const}  returns a copy of the filter kernel.\par}
\par
\par}
{\bkmkstart AAAAAAAABG}
{\bkmkend AAAAAAAABG}
{{\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Python
\par}
{\tc\tcl4 \v Python}
{
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\f2 getCoeff(n : int) -> numpy.array}  as per the C++ method, following the zero-padding and exception-throwing behaviour of the C++. The returned array will have {\f2 n}  elements.\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\f2 getCoeff() -> numpy.array}  additional to the C++ methods, this returns an numpy array which is a copy of the filter kernel. This is probably the default use case in Python.\par}
\par
\par}
{\bkmkstart AAAAAAAABH}
{\bkmkend AAAAAAAABH}
{{\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
JAVA
\par}
{\tc\tcl4 \v JAVA}
{
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\f2 double[] getCoeff()}  returns a double array of the filter kernel.\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\f2 double[] getCoeff(n : int)}  as per the C++ method, following the zero-padding and exception-throwing behaviour of the C++. The returned array will have {\f2 n}  elements.\par}
\par
\par}
\par}
{\bkmkstart AAAAAAAABI}
{\bkmkend AAAAAAAABI}
{{\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Destructor
\par}
{\tc\tcl3 \v Destructor}
{\bkmkstart AAAAAAAABJ}
{\bkmkend AAAAAAAABJ}
{{\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
C++
\par}
{\tc\tcl4 \v C++}
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid delete fir;\par
}
\par}
{\bkmkstart AAAAAAAABK}
{\bkmkend AAAAAAAABK}
{{\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
JAVA
\par}
{\tc\tcl4 \v JAVA}
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid fir.release();\par
}
 to release the underlying C++ class.\par}
\par}
\par}
{\bkmkstart AAAAAAAABL}
{\bkmkend AAAAAAAABL}
{{\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
LMS algorithm
\par}
{\tc\tcl2 \v LMS algorithm}
The least mean square algorithm adjusts the FIR coefficients h_m with the help of an error signal e(n): {
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid h_m(n+1) = h_m(n) + learning_rate * h_m(n) * e(n)\par
}
 using the function {\f2 lms_update(e)}  while performing the filtering with {\f2 filter()} .\par
{\bkmkstart AAAAAAAABM}
{\bkmkend AAAAAAAABM}
{{\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
How to use the filter
\par}
{\tc\tcl3 \v How to use the filter}
{
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Construct the Fir filter with all coefficients set to zero: {\f2 {\b Fir1(nCoeff)}} \par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Set the learning_rate with the method {\f2 setLearningRate(learning_rate)} .\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Provide the input signal {\f2 x}  to the FIR filter and use its standard {\f2 filter}  method to filter it.\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Define your error which needs to be minimised: {\f2 e = d - y} \par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Feed the error back into the filter with the method {\f2 lms_update(e)} .\par}
\par
The {\f2 lmsdemo}  in the demo directory makes this concept much clearer how to remove artefacts with this method.\par
The above plot shows the filter in action which removes 50Hz noise with the adaptive filter. Learning is very fast and the learning rate here is deliberately kept low to show how it works.\par}
{\bkmkstart AAAAAAAABN}
{\bkmkend AAAAAAAABN}
{{\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Stability
\par}
{\tc\tcl3 \v Stability}
The FIR filter itself is stable but the error signal changes the filter coefficients which in turn change the error and so on. There is a rule of thumb that the learning rate should be less than the "tap power" of the input signal which is just the sum of all squared values held in the different taps: {
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid learning_rate < 1/getTapInputPower()\par
}
 That allows an adaptive learning rate which is called "normalised LMS". From my experiments that works in theory but in practise the realtime value of getTapInputPower() can make the algorithm easily unstable because it might suggest infinite learning rates and can fluctuate wildly. A better approach is to keep the learning rate constant and rather control the power of the input signal by, for example, normalising the input signal or limiting it.\par
See the demo below which removes 50Hz from an ECG which uses a normalised 50Hz signal which guarantees stability by design.\par}
{\bkmkstart AAAAAAAABO}
{\bkmkend AAAAAAAABO}
{{\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
JAVA/Python
\par}
{\tc\tcl3 \v JAVA/Python}
The commands under JAVA and Python are identical to C++.\par}
\par}
{\bkmkstart AAAAAAAABP}
{\bkmkend AAAAAAAABP}
{{\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Demos
\par}
{\tc\tcl2 \v Demos}
Demo programs are in the "demo" directory which show how to use the filters for both floating point and fixed point.{
\par
\pard\plain \s140\fi-360\li360\widctlpar\fs20\cgrid 
1.\tab {\f2 firdemo}  sends an impulse into the filter and you should see the impulse response at its output.\par
\pard\plain \s140\fi-360\li360\widctlpar\fs20\cgrid 
2.\tab {\f2 fixeddemo}  filters an example ECG with 50Hz noise. The coefficients are 12 bit and you can generate them either with OCTAVE/MATLAB or Python. The scripts are also provided.\par
\pard\plain \s140\fi-360\li360\widctlpar\fs20\cgrid 
3.\tab {\f2 lmsdemo}  filters out 50Hz noise from an ECG with the help of adaptive filtering by using the 50Hz powerline frequency as the input to the filter. This can be replaced by any reference artefact signal or signal which is correlated with the artefact.\par
\pard\plain \s140\fi-360\li360\widctlpar\fs20\cgrid 
4.\tab JAVA has an {\f2 InstrumentedTest}  which filters both a delta pulse and a step function.\par
\pard\plain \s140\fi-360\li360\widctlpar\fs20\cgrid 
5.\tab filter_ecg.py performs the filtering of an ECG in python using the fir1 python module which in turn calls internally the C++ functions.\par}
\par
\par}
{\bkmkstart AAAAAAAABQ}
{\bkmkend AAAAAAAABQ}
{{\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C++ documentation
\par}
{\tc\tcl2 \v C++ documentation}
The doxygen generated documentation can be found here:\par
{
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Online: {\f2 http://berndporr.github.io/fir1/index.html}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
PDF: {\f2 https://github.com/berndporr/fir1/tree/master/docs/pdf}\par}
\par
\par}
{\bkmkstart AAAAAAAABR}
{\bkmkend AAAAAAAABR}
{{\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Unit tests
\par}
{\tc\tcl2 \v Unit tests}
Under C++ just run {\f2 make test}  or {\f2 ctest} .\par
The JAVA wrapper contains an instrumented test which you can run on your Android device.\par}
{\bkmkstart AAAAAAAABS}
{\bkmkend AAAAAAAABS}
{{\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Credits
\par}
{\tc\tcl2 \v Credits}
This library has been adapted form Graeme Hattan's original C code.\par
Enjoy!\par
Bernd Porr & Nick Bailey \par}
}}

\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
AudioFile{\tc \v AudioFile}\par \pard\plain 
{\bkmkstart AAAAAAAAEX}
{\bkmkend AAAAAAAAEX}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
  \par
A simple header-only C++ library for reading and writing audio files.\par
Current supported formats:\par
{
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
WAV\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
AIFF\par}
\par
{\bkmkstart AAAAAAAABT}
{\bkmkend AAAAAAAABT}
{{\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Author
\par}
{\tc\tcl2 \v Author}
{\b AudioFile} is written and maintained by Adam Stark.\par
{\f2 http://www.adamstark.co.uk}\par}
{\bkmkstart AAAAAAAABU}
{\bkmkend AAAAAAAABU}
{{\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Usage
\par}
{\tc\tcl2 \v Usage}
{\bkmkstart AAAAAAAABV}
{\bkmkend AAAAAAAABV}
{{\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Create an AudioFile object:
\par}
{\tc\tcl3 \v Create an AudioFile object:}
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid     #include "AudioFile.h"\par
\par
    AudioFile<double> audioFile;\par
}
 \par}
{\bkmkstart AAAAAAAABW}
{\bkmkend AAAAAAAABW}
{{\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Load an audio file:
\par}
{\tc\tcl3 \v Load an audio file:}
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid     audioFile.load ("/path/to/my/audiofile.wav");\par
}
 \par}
{\bkmkstart AAAAAAAABX}
{\bkmkend AAAAAAAABX}
{{\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Get some information about the loaded audio:
\par}
{\tc\tcl3 \v Get some information about the loaded audio:}
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid     int sampleRate = audioFile.getSampleRate();\par
    int bitDepth = audioFile.getBitDepth();\par
\par
    int numSamples = audioFile.getNumSamplesPerChannel();\par
    double lengthInSeconds = audioFile.getLengthInSeconds();\par
\par
    int numChannels = audioFile.getNumChannels();\par
    bool isMono = audioFile.isMono();\par
    bool isStereo = audioFile.isStereo();\par
\par
    // or, just use this quick shortcut to print a summary to the console\par
    audioFile.printSummary();\par
}
 \par}
{\bkmkstart AAAAAAAABY}
{\bkmkend AAAAAAAABY}
{{\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Access the samples directly:
\par}
{\tc\tcl3 \v Access the samples directly:}
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid     int channel = 0;\par
    int numSamples = audioFile.getNumSamplesPerChannel();\par
\par
    for (int i = 0; i < numSamples; i++)\par
    \{\par
            double currentSample = audioFile.samples[channel][i];\par
    \}\par
}
 \par}
{\bkmkstart AAAAAAAABZ}
{\bkmkend AAAAAAAABZ}
{{\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Replace the AudioFile audio buffer with another
\par}
{\tc\tcl3 \v Replace the AudioFile audio buffer with another}
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid     // 1. Create an AudioBuffer \par
    // (BTW, AudioBuffer is just a vector of vectors)\par
\par
    AudioFile<double>::AudioBuffer buffer;\par
\par
    // 2. Set to (e.g.) two channels\par
    buffer.resize (2);\par
\par
    // 3. Set number of samples per channel\par
    buffer[0].resize (100000);\par
    buffer[1].resize (100000);\par
\par
    // 4. do something here to fill the buffer with samples, e.g.\par
\par
    #include <math.h> // somewhere earler (for M_PI and sinf())\par
\par
    // then...\par
\par
    int numChannels = 2;\par
    int numSamplesPerChannel = 100000;\par
    float sampleRate = 44100.f;\par
    float frequency = 440.f;\par
\par
    for (int i = 0; i < numSamplesPerChannel; i++)\par
    \{\par
    float sample = sinf (2. * M_PI * ((float) i / sampleRate) * frequency) ;\par
\par
    for (int channel = 0; channel < numChannels; channel++)\par
         buffer[channel][i] = sample * 0.5;\par
    \}\par
\par
    // 5. Put into the AudioFile object\par
    bool ok = audioFile.setAudioBuffer (buffer);\par
}
\par}
{\bkmkstart AAAAAAAACA}
{\bkmkend AAAAAAAACA}
{{\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Resize the audio buffer
\par}
{\tc\tcl3 \v Resize the audio buffer}
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid     // Set both the number of channels and number of samples per channel\par
    audioFile.setAudioBufferSize (numChannels, numSamples);\par
\par
    // Set the number of samples per channel\par
    audioFile.setNumSamplesPerChannel (numSamples);\par
\par
    // Set the number of channels\par
    audioFile.setNumChannels (int numChannels);\par
}
 \par}
{\bkmkstart AAAAAAAACB}
{\bkmkend AAAAAAAACB}
{{\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Set bit depth and sample rate
\par}
{\tc\tcl3 \v Set bit depth and sample rate}
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid     audioFile.setBitDepth (24);\par
    audioFile.setSampleRate (44100);\par
}
 \par}
{\bkmkstart AAAAAAAACC}
{\bkmkend AAAAAAAACC}
{{\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Save the audio file to disk
\par}
{\tc\tcl3 \v Save the audio file to disk}
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid     // Wave file (implicit)\par
    audioFile.save ("path/to/desired/audioFile.wav");\par
\par
    // Wave file (explicit)\par
    audioFile.save ("path/to/desired/audioFile.wav", AudioFileFormat::Wave);\par
\par
    // Aiff file\par
    audioFile.save ("path/to/desired/audioFile.aif", AudioFileFormat::Aiff);\par
}
\par}
\par}
{\bkmkstart AAAAAAAACD}
{\bkmkend AAAAAAAACD}
{{\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Examples
\par}
{\tc\tcl2 \v Examples}
Please see the {\f2 examples}  folder for some examples on library usage.\par}
{\bkmkstart AAAAAAAACE}
{\bkmkend AAAAAAAACE}
{{\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
A Note On Types
\par}
{\tc\tcl2 \v A Note On Types}
{\b AudioFile} is a template class and so it can be instantiated using floating point precision: {
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid     AudioFile<float> audioFile;\par
}
 ...or double precision: {
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid     AudioFile<double> audioFile;\par
}
 This simply reflects the data type you would like to use to store the underlying audio samples. You can still read or write 8, 16 or 24-bit audio files, regardless of the type that you use (unless your system uses a precision for floats less than your desired bit depth).\par
I have heard of people using the library with other types, but I have not designed for those cases. Let me know if you are interested in this supporting a specific type more formally.\par}
{\bkmkstart AAAAAAAACF}
{\bkmkend AAAAAAAACF}
{{\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Error Messages
\par}
{\tc\tcl2 \v Error Messages}
By default, the library logs error messages to the console to provide information on what has gone wrong (e.g. a file we tried to load didn't exist).\par
If you prefer not to see these messages, you can disable this error logging behaviour using: {
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid     audioFile.shouldLogErrorsToConsole (false);\par
}
\par}
{\bkmkstart AAAAAAAACG}
{\bkmkend AAAAAAAACG}
{{\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Versions
\par}
{\tc\tcl2 \v Versions}
{\bkmkstart AAAAAAAACH}
{\bkmkend AAAAAAAACH}
{{\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
1.1.0 - 15th January 2022
\par}
{\tc\tcl4 \v 1.1.0 - 15th January 2022}
{
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Moved project to MIT licence\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Added option to load an audio file already in memory\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
CI Workflow improvements and bug fixes\par}
\par
\par}
{\bkmkstart AAAAAAAACI}
{\bkmkend AAAAAAAACI}
{{\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
1.0.9 - 23rd January 2021
\par}
{\tc\tcl4 \v 1.0.9 - 23rd January 2021}
{
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Faster loading of audio files\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Bug fixes\par}
\par
\par}
{\bkmkstart AAAAAAAACJ}
{\bkmkend AAAAAAAACJ}
{{\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
1.0.8 - 18th October 2020
\par}
{\tc\tcl4 \v 1.0.8 - 18th October 2020}
{
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
CMake support\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Construct instances with a file path\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Bug fixes\par}
\par
\par}
{\bkmkstart AAAAAAAACK}
{\bkmkend AAAAAAAACK}
{{\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
1.0.7 - 3rd July 2020
\par}
{\tc\tcl4 \v 1.0.7 - 3rd July 2020}
{
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Support for 32-bit audio files\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Support for multi-channel audio files\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Reading/writing of {\f2 iXML data chunks}\par}
\par
\par}
{\bkmkstart AAAAAAAACL}
{\bkmkend AAAAAAAACL}
{{\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
1.0.6 - 29th February 2020
\par}
{\tc\tcl4 \v 1.0.6 - 29th February 2020}
{
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Made error logging to the console optional\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Fixed lots of compiler warnings\par}
\par
\par}
{\bkmkstart AAAAAAAACM}
{\bkmkend AAAAAAAACM}
{{\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
1.0.5 - 14th October 2019
\par}
{\tc\tcl4 \v 1.0.5 - 14th October 2019}
{
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Added include of <algorithm> to better support Visual Studio\par}
\par
\par}
{\bkmkstart AAAAAAAACN}
{\bkmkend AAAAAAAACN}
{{\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
1.0.4 - 13th October 2019
\par}
{\tc\tcl4 \v 1.0.4 - 13th October 2019}
{
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Changed to a header-only library. Now you can just include {\b AudioFile.h}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Bug fixes\par}
\par
\par}
{\bkmkstart AAAAAAAACO}
{\bkmkend AAAAAAAACO}
{{\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
1.0.3 - 28th October 2018
\par}
{\tc\tcl4 \v 1.0.3 - 28th October 2018}
{
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Bug fixes\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Documentation updates\par}
\par
\par}
{\bkmkstart AAAAAAAACP}
{\bkmkend AAAAAAAACP}
{{\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
1.0.2 - 6th June 2017
\par}
{\tc\tcl4 \v 1.0.2 - 6th June 2017}
{
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Bug fixes\par}
\par
\par}
\par}
{\bkmkstart AAAAAAAACQ}
{\bkmkend AAAAAAAACQ}
{{\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Contributions
\par}
{\tc\tcl2 \v Contributions}
{
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Multichannel (i.e. >2 channels) audio file support ({\f2 Sidelobe})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Read/write of iXML data chunks ({\f2 mynameisjohn})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Remove warnings ({\f2 Abhinav1997})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Better support on Ubuntu ({\f2 BenjaminHinchliff})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Faster loading of audio files ({\f2 helloimmatt})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Improvements to Github Actions workflow ({\f2 emiro85})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Pull request review ({\f2 MatthieuHernandez})\par}
\par
\par}
{\bkmkstart AAAAAAAACR}
{\bkmkend AAAAAAAACR}
{{\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Want to Contribute?
\par}
{\tc\tcl2 \v Want to Contribute?}
If you would like to submit a pull request for this library, please do! But kindly follow the following simple guidelines...\par
{
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Make the changes as concise as is possible for the change you are proposing\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Avoid unnecessarily changing a large number of lines - e.g. commits changing the number of spaces in indentations on all lines (and so on)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Keep to the code style of this library which is the {\f2 JUCE Coding Standards}\par}
\par
\par}
{\bkmkstart AAAAAAAACS}
{\bkmkend AAAAAAAACS}
{{\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
License
\par}
{\tc\tcl2 \v License}
MIT License\par
Copyright (c) 2017 Adam Stark\par
Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\par
The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\par
THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. \par}
}}

\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
Signal Cleaner{\tc \v Signal Cleaner}\par \pard\plain 
{\bkmkstart AAAAAAAAEY}
{\bkmkend AAAAAAAAEY}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The {\f2 signal-cleaner}  tool may be used to run the lms fir algorithm on a noisey input file and produce a clean output file. The noise source is also required. All inputs are files with {\f2 .wav}  extenstion.\par
{\bkmkstart AAAAAAAACT}
{\bkmkend AAAAAAAACT}
{{\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Build
\par}
{\tc\tcl2 \v Build}
To try out {\f2 signal-cleaner} , you can build the program with {\f2 cmake}  from the root level {\f2 fir/}  directory or from this directory as shown:\par
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid cmake .\par
make\par
}
\par}
{\bkmkstart AAAAAAAACU}
{\bkmkend AAAAAAAACU}
{{\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Usage
\par}
{\tc\tcl2 \v Usage}
A usage example is provided below:\par
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid Usage: ./signal-cleaner[-l <lrate>] [-n <ntaps>] [-o <file>] <noise-source> [<input>]\par
}
\par
As well as providing input and noise sources, the {\f2 ntaps}  and {\f2 lrate}  for the filter may be configured.\par
If no output file is specified, the program will output to {\f2 stdout} .\par
If no input file is specified, the program will input from {\f2 stdin} .\par}
{\bkmkstart AAAAAAAACV}
{\bkmkend AAAAAAAACV}
{{\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Output
\par}
{\tc\tcl2 \v Output}
The output file is the filtered result. \par}
}}

\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
Correlate{\tc \v Correlate}\par \pard\plain 
{\bkmkstart AAAAAAAAEZ}
{\bkmkend AAAAAAAAEZ}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The {\f2 wave-correlate}  tool provides facility to compute standard deviation, covariance, pearsons correlation coeffiecient and SNR for input wav files.\par
{\bkmkstart AAAAAAAACW}
{\bkmkend AAAAAAAACW}
{{\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Build
\par}
{\tc\tcl2 \v Build}
To try out {\f2 wav-correlate} , you can build the program with {\f2 cmake}  from the root level {\f2 fir/}  directory or from this directory as shown:\par
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid cmake .\par
make\par
}
\par}
{\bkmkstart AAAAAAAACX}
{\bkmkend AAAAAAAACX}
{{\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Usage
\par}
{\tc\tcl2 \v Usage}
Example usage is shown:\par
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid Usage: wav-correlate <file1> [<file2>]\par
}
\par
If no secondary file is specified, the program will read from {\f2 stdin} .\par}
{\bkmkstart AAAAAAAACY}
{\bkmkend AAAAAAAACY}
{{\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Output
\par}
{\tc\tcl2 \v Output}
The program outputs metrics to {\f2 stdout} . Example program usage and output is shown:\par
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid $ correlate/wav-correlate wav-files/sinewave441Hz.wav wav-files/sinewave882Hz.wav\par
\par
MEAN1  : -3.05176e-07\par
MEAN2  : 0\par
STDEV1 : 0.707091\par
STDEV2 : 0.707095\par
COV    : 2.62016e-22\par
RHO    : 5.24051e-22\par
SNR    : -980.009 dB\par
}
 \par}
}}

\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
Class Index\par \pard\plain 
{\tc \v Class Index}
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Class List\par \pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Here are the classes, structs, unions and interfaces with brief descriptions:}
{
\par
\pard\plain \s101\li360\sa27\sb27\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
{\b {\b AudioFile< T >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAACZ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b Fir1} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAADW \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b Fir1fixed} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAEN \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b SignalCleaner} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAEV \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
\par}
\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
File Index\par \pard\plain 
{\tc \v File Index}
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
File List\par \pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Here is a list of all documented files with brief descriptions:}
{
\par
\pard\plain \s101\li360\sa27\sb27\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
{\b {\b Fir1.h} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAAC \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b Fir1fixed.h} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAAD \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b AudioFile/{\b AudioFile.h} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAAF \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b correlate/{\b correlate.h} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAAB \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b SignalCleaner/{\b SignalCleaner.h} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAAE \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
\par}
\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
Class Documentation{\tc \v Class Documentation}
\par \pard\plain 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
AudioFile< T > Class Template Reference\par \pard\plain 
{\tc\tcl2 \v AudioFile< T >}
{\xe \v AudioFile< T >}
{\bkmkstart AAAAAAAACZ}
{\bkmkend AAAAAAAACZ}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b AudioFile} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b AudioFile} (std::string filePath)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b load} (std::string filePath)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b save} (std::string filePath, {\b AudioFileFormat} format=AudioFileFormat::Wave)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b loadFromMemory} (std::vector< uint8_t > &fileData)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint32_t {\b getSampleRate} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b getNumChannels} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b isMono} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b isStereo} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b getBitDepth} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b getNumSamplesPerChannel} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b getLengthInSeconds} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b printSummary} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b setAudioBuffer} (AudioBuffer &newBuffer)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setAudioBufferSize} (int numChannels, int numSamples)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setNumSamplesPerChannel} (int numSamples)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setNumChannels} (int numChannels)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setBitDepth} (int numBitsPerSample)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setSampleRate} (uint32_t newSampleRate)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b shouldLogErrorsToConsole} (bool logErrors)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
AudioBuffer {\b samples}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::string {\b iXMLChunk}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v AudioFile\:AudioFile< T >}
{\xe \v AudioFile< T >\:AudioFile}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class T > {\b AudioFile}< T >{\b ::AudioFile}}}
\par
{\bkmkstart AAAAAAAADA}
{\bkmkend AAAAAAAADA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Constructor \par
}}
{\xe \v AudioFile\:AudioFile< T >}
{\xe \v AudioFile< T >\:AudioFile}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class T > {\b AudioFile}< T >{\b ::AudioFile} (std::string  {\i filePath})}}
\par
{\bkmkstart AAAAAAAADB}
{\bkmkend AAAAAAAADB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Constructor, using a given file path to load a file \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v getBitDepth\:AudioFile< T >}
{\xe \v AudioFile< T >\:getBitDepth}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class T > int {\b AudioFile}< T >::getBitDepth}}
\par
{\bkmkstart AAAAAAAADC}
{\bkmkend AAAAAAAADC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
@Returns the bit depth of each sample \par
}}
{\xe \v getLengthInSeconds\:AudioFile< T >}
{\xe \v AudioFile< T >\:getLengthInSeconds}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class T > double {\b AudioFile}< T >::getLengthInSeconds}}
\par
{\bkmkstart AAAAAAAADD}
{\bkmkend AAAAAAAADD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
@Returns the length in seconds of the audio file based on the number of samples and sample rate \par
}}
{\xe \v getNumChannels\:AudioFile< T >}
{\xe \v AudioFile< T >\:getNumChannels}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class T > int {\b AudioFile}< T >::getNumChannels}}
\par
{\bkmkstart AAAAAAAADE}
{\bkmkend AAAAAAAADE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
@Returns the number of audio channels in the buffer \par
}}
{\xe \v getNumSamplesPerChannel\:AudioFile< T >}
{\xe \v AudioFile< T >\:getNumSamplesPerChannel}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class T > int {\b AudioFile}< T >::getNumSamplesPerChannel}}
\par
{\bkmkstart AAAAAAAADF}
{\bkmkend AAAAAAAADF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
@Returns the number of samples per channel \par
}}
{\xe \v getSampleRate\:AudioFile< T >}
{\xe \v AudioFile< T >\:getSampleRate}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class T > uint32_t {\b AudioFile}< T >::getSampleRate}}
\par
{\bkmkstart AAAAAAAADG}
{\bkmkend AAAAAAAADG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
@Returns the sample rate \par
}}
{\xe \v isMono\:AudioFile< T >}
{\xe \v AudioFile< T >\:isMono}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class T > bool {\b AudioFile}< T >::isMono}}
\par
{\bkmkstart AAAAAAAADH}
{\bkmkend AAAAAAAADH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
@Returns true if the audio file is mono \par
}}
{\xe \v isStereo\:AudioFile< T >}
{\xe \v AudioFile< T >\:isStereo}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class T > bool {\b AudioFile}< T >::isStereo}}
\par
{\bkmkstart AAAAAAAADI}
{\bkmkend AAAAAAAADI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
@Returns true if the audio file is stereo \par
}}
{\xe \v load\:AudioFile< T >}
{\xe \v AudioFile< T >\:load}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class T > bool {\b AudioFile}< T >::load (std::string  {\i filePath})}}
\par
{\bkmkstart AAAAAAAADJ}
{\bkmkend AAAAAAAADJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Loads an audio file from a given file path. @Returns true if the file was successfully loaded \par
}}
{\xe \v loadFromMemory\:AudioFile< T >}
{\xe \v AudioFile< T >\:loadFromMemory}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class T > bool {\b AudioFile}< T >::loadFromMemory (std::vector< uint8_t > &  {\i fileData})}}
\par
{\bkmkstart AAAAAAAADK}
{\bkmkend AAAAAAAADK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Loads an audio file from data in memory \par
}}
{\xe \v printSummary\:AudioFile< T >}
{\xe \v AudioFile< T >\:printSummary}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class T > void {\b AudioFile}< T >::printSummary}}
\par
{\bkmkstart AAAAAAAADL}
{\bkmkend AAAAAAAADL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Prints a summary of the audio file to the console \par
}}
{\xe \v save\:AudioFile< T >}
{\xe \v AudioFile< T >\:save}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class T > bool {\b AudioFile}< T >::save (std::string  {\i filePath}, {\b AudioFileFormat}  {\i format} = {\f2 AudioFileFormat::Wave})}}
\par
{\bkmkstart AAAAAAAADM}
{\bkmkend AAAAAAAADM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Saves an audio file to a given file path. @Returns true if the file was successfully saved \par
}}
{\xe \v setAudioBuffer\:AudioFile< T >}
{\xe \v AudioFile< T >\:setAudioBuffer}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class T > bool {\b AudioFile}< T >::setAudioBuffer (AudioBuffer &  {\i newBuffer})}}
\par
{\bkmkstart AAAAAAAADN}
{\bkmkend AAAAAAAADN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Set the audio buffer for this {\b AudioFile} by copying samples from another buffer. @Returns true if the buffer was copied successfully. \par
}}
{\xe \v setAudioBufferSize\:AudioFile< T >}
{\xe \v AudioFile< T >\:setAudioBufferSize}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class T > void {\b AudioFile}< T >::setAudioBufferSize (int  {\i numChannels}, int  {\i numSamples})}}
\par
{\bkmkstart AAAAAAAADO}
{\bkmkend AAAAAAAADO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets the audio buffer to a given number of channels and number of samples per channel. This will try to preserve the existing audio, adding zeros to any new channels or new samples in a given channel. \par
}}
{\xe \v setBitDepth\:AudioFile< T >}
{\xe \v AudioFile< T >\:setBitDepth}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class T > void {\b AudioFile}< T >::setBitDepth (int  {\i numBitsPerSample})}}
\par
{\bkmkstart AAAAAAAADP}
{\bkmkend AAAAAAAADP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets the bit depth for the audio file. If you use the {\b save()} function, this bit depth rate will be used \par
}}
{\xe \v setNumChannels\:AudioFile< T >}
{\xe \v AudioFile< T >\:setNumChannels}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class T > void {\b AudioFile}< T >::setNumChannels (int  {\i numChannels})}}
\par
{\bkmkstart AAAAAAAADQ}
{\bkmkend AAAAAAAADQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets the number of channels. New channels will have the correct number of samples and be initialised to zero \par
}}
{\xe \v setNumSamplesPerChannel\:AudioFile< T >}
{\xe \v AudioFile< T >\:setNumSamplesPerChannel}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class T > void {\b AudioFile}< T >::setNumSamplesPerChannel (int  {\i numSamples})}}
\par
{\bkmkstart AAAAAAAADR}
{\bkmkend AAAAAAAADR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets the number of samples per channel in the audio buffer. This will try to preserve the existing audio, adding zeros to new samples in a given channel if the number of samples is increased. \par
}}
{\xe \v setSampleRate\:AudioFile< T >}
{\xe \v AudioFile< T >\:setSampleRate}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class T > void {\b AudioFile}< T >::setSampleRate (uint32_t  {\i newSampleRate})}}
\par
{\bkmkstart AAAAAAAADS}
{\bkmkend AAAAAAAADS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets the sample rate for the audio file. If you use the {\b save()} function, this sample rate will be used \par
}}
{\xe \v shouldLogErrorsToConsole\:AudioFile< T >}
{\xe \v AudioFile< T >\:shouldLogErrorsToConsole}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class T > void {\b AudioFile}< T >::shouldLogErrorsToConsole (bool  {\i logErrors})}}
\par
{\bkmkstart AAAAAAAADT}
{\bkmkend AAAAAAAADT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets whether the library should log error messages to the console. By default this is true \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v iXMLChunk\:AudioFile< T >}
{\xe \v AudioFile< T >\:iXMLChunk}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class T > std::string {\b AudioFile}< T >::iXMLChunk}}
\par
{\bkmkstart AAAAAAAADU}
{\bkmkend AAAAAAAADU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
An optional iXML chunk that can be added to the {\b AudioFile}. \par
}}
{\xe \v samples\:AudioFile< T >}
{\xe \v AudioFile< T >\:samples}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class T > AudioBuffer {\b AudioFile}< T >::samples}}
\par
{\bkmkstart AAAAAAAADV}
{\bkmkend AAAAAAAADV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A vector of vectors holding the audio samples for the {\b AudioFile}. You can access the samples by channel and then by sample index, i.e: {
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  samples[channel][sampleIndex]\par
}
 \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
AudioFile/{\b AudioFile.h}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Fir1 Class Reference\par \pard\plain 
{\tc\tcl2 \v Fir1}
{\xe \v Fir1}
{\bkmkstart AAAAAAAADW}
{\bkmkend AAAAAAAADW}
\par
{
{\f2 #include <Fir1.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<unsigned nTaps> {\b Fir1} (const double(&_coefficients)[nTaps])\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Fir1} (std::vector< double > _coefficients)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Fir1} (double *coefficients, unsigned number_of_taps)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Fir1} (const char *coeffFile, unsigned number_of_taps=0)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Fir1} (unsigned number_of_taps)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ~Fir1} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b filter} (double input)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b lms_update} (double error)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setLearningRate} (double _mu)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b getLearningRate} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b reset} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b zeroCoeff} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b getCoeff} (double *coeff_data, unsigned number_of_taps) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::vector< double > {\b getCoeffVector} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned {\b getTaps} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b getTapInputPower} ()\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Finite impulse response filter. The precision is double. It takes as an input a file with coefficients or an double array. \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v Fir1\:Fir1}
{\xe \v Fir1\:Fir1}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<unsigned nTaps> Fir1::Fir1 (const double(&)  {\i _coefficients}[nTaps]){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAADX}
{\bkmkend AAAAAAAADX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Coefficients as a const double array. Because the array is const the number of taps is identical to the length of the array. {\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i _coefficients} \cell }{A const double array with the impulse response. \cell }
{\row }
}
}}
{\xe \v Fir1\:Fir1}
{\xe \v Fir1\:Fir1}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
Fir1::Fir1 (std::vector< double >  {\i _coefficients}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAADY}
{\bkmkend AAAAAAAADY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Coefficients as a C++ vector {\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i _coefficients} \cell }{is a Vector of doubles. \cell }
{\row }
}
}}
{\xe \v Fir1\:Fir1}
{\xe \v Fir1\:Fir1}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
Fir1::Fir1 (double *  {\i coefficients}, unsigned  {\i number_of_taps})}}
\par
{\bkmkstart AAAAAAAADZ}
{\bkmkend AAAAAAAADZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Coefficients as a (non-constant-) double array where the length needs to be specified. {\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i coefficients} \cell }{Coefficients as double array. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i number_of_taps} \cell }{Number of taps (needs to match the number of coefficients \cell }
{\row }
}
}}
{\xe \v Fir1\:Fir1}
{\xe \v Fir1\:Fir1}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
Fir1::Fir1 (const char *  {\i coeffFile}, unsigned  {\i number_of_taps} = {\f2 0})}}
\par
{\bkmkstart AAAAAAAAEA}
{\bkmkend AAAAAAAAEA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Coefficients as a text file (for example from Python) The number of taps is automatically detected when the taps are kept zero. {\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i coeffFile} \cell }{Patht to textfile where every line contains one coefficient \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i number_of_taps} \cell }{Number of taps (0 = autodetect) \cell }
{\row }
}
}}
{\xe \v Fir1\:Fir1}
{\xe \v Fir1\:Fir1}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
Fir1::Fir1 (unsigned  {\i number_of_taps})}}
\par
{\bkmkstart AAAAAAAAEB}
{\bkmkend AAAAAAAAEB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Inits all coefficients and the buffer to zero This is useful for adaptive filters where we start with zero valued coefficients. \par
}}
{\xe \v ~Fir1\:Fir1}
{\xe \v Fir1\:~Fir1}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
Fir1::~Fir1 ()}}
\par
{\bkmkstart AAAAAAAAEC}
{\bkmkend AAAAAAAAEC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Releases the coefficients and buffer. \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v filter\:Fir1}
{\xe \v Fir1\:filter}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double Fir1::filter (double  {\i input}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAED}
{\bkmkend AAAAAAAAED}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The actual filter function operation: it receives one sample and returns one sample. {\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i input} \cell }{The input sample. \cell }
{\row }
}
}}
{\xe \v getCoeff\:Fir1}
{\xe \v Fir1\:getCoeff}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Fir1::getCoeff (double *  {\i coeff_data}, unsigned  {\i number_of_taps}) const}}
\par
{\bkmkstart AAAAAAAAEE}
{\bkmkend AAAAAAAAEE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Copies the current filter coefficients into a provided array. Useful after an adaptive filter has been trained to query the result of its training. {\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i coeff_data} \cell }{target where coefficients are copied \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i number_of_taps} \cell }{number of doubles to be copied \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Exceptions\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i std::out_of_range} \cell }{number_of_taps is less the actual number of taps. \cell }
{\row }
}
}}
{\xe \v getCoeffVector\:Fir1}
{\xe \v Fir1\:getCoeffVector}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::vector< double > Fir1::getCoeffVector () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAEF}
{\bkmkend AAAAAAAAEF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the coefficients as a vector \par
}}
{\xe \v getLearningRate\:Fir1}
{\xe \v Fir1\:getLearningRate}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double Fir1::getLearningRate (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAEG}
{\bkmkend AAAAAAAAEG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Getting the learning rate for the adaptive filter. \par
}}
{\xe \v getTapInputPower\:Fir1}
{\xe \v Fir1\:getTapInputPower}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double Fir1::getTapInputPower (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAEH}
{\bkmkend AAAAAAAAEH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the power of the of the buffer content: sum_k buffer[k]^2 which is needed to implement a normalised LMS algorithm. \par
}}
{\xe \v getTaps\:Fir1}
{\xe \v Fir1\:getTaps}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned Fir1::getTaps (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAEI}
{\bkmkend AAAAAAAAEI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the number of taps. \par
}}
{\xe \v lms_update\:Fir1}
{\xe \v Fir1\:lms_update}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Fir1::lms_update (double  {\i error}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAEJ}
{\bkmkend AAAAAAAAEJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
LMS adaptive filter weight update: Every filter coefficient is updated with: w_k(n+1) = w_k(n) + learning_rate * buffer_k(n) * error(n) {\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i error} \cell }{Is the term error(n), the error which adjusts the FIR conefficients. \cell }
{\row }
}
}}
{\xe \v reset\:Fir1}
{\xe \v Fir1\:reset}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Fir1::reset ()}}
\par
{\bkmkstart AAAAAAAAEK}
{\bkmkend AAAAAAAAEK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Resets the buffer (but not the coefficients) \par
}}
{\xe \v setLearningRate\:Fir1}
{\xe \v Fir1\:setLearningRate}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Fir1::setLearningRate (double  {\i _mu}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAEL}
{\bkmkend AAAAAAAAEL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Setting the learning rate for the adaptive filter. {\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i _mu} \cell }{The learning rate (i.e. rate of the change by the error signal) \cell }
{\row }
}
}}
{\xe \v zeroCoeff\:Fir1}
{\xe \v Fir1\:zeroCoeff}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Fir1::zeroCoeff ()}}
\par
{\bkmkstart AAAAAAAAEM}
{\bkmkend AAAAAAAAEM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets all coefficients to zero \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Fir1.h\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Fir1.cpp\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Fir1fixed Class Reference\par \pard\plain 
{\tc\tcl2 \v Fir1fixed}
{\xe \v Fir1fixed}
{\bkmkstart AAAAAAAAEN}
{\bkmkend AAAAAAAAEN}
\par
{
{\f2 #include <Fir1fixed.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Fir1fixed} (short int *coefficients, unsigned bitshift, unsigned number_of_taps)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<unsigned nTaps> {\b Fir1fixed} (const short int(&_coefficients)[nTaps], unsigned bitshift)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Fir1fixed} (const char *coeffFile, unsigned bitshift, unsigned number_of_taps=0)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename Sample > Sample {\b filter} (Sample input)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ~Fir1fixed} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b reset} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned {\b getTaps} ()\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Fixed point FIR filter with short int coefficients and data processed as int. \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v Fir1fixed\:Fir1fixed}
{\xe \v Fir1fixed\:Fir1fixed}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
Fir1fixed::Fir1fixed (short int *  {\i coefficients}, unsigned  {\i bitshift}, unsigned  {\i number_of_taps})}}
\par
{\bkmkstart AAAAAAAAEO}
{\bkmkend AAAAAAAAEO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Coefficients as an array of short ints (and length provided separately) {\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i coefficients} \cell }{Array of the coefficients scaled up by 2^bitshift \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i bitshift} \cell }{Scaling factor of the coefficients as power of 2: 2^bitshift \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i number_of_taps} \cell }{Number of taps (= number of coefficients) \cell }
{\row }
}
}}
{\xe \v Fir1fixed\:Fir1fixed}
{\xe \v Fir1fixed\:Fir1fixed}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<unsigned nTaps> Fir1fixed::Fir1fixed (const short int(&)  {\i _coefficients}[nTaps], unsigned  {\i bitshift}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAEP}
{\bkmkend AAAAAAAAEP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Coefficients as an const array of short ints (and length automatically detected) {\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i _coefficients} \cell }{Array of the coefficients (const short) scaled up by 2^bitshift \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i bitshift} \cell }{Scaling factor of the coefficients as power of 2: 2^bitshift \cell }
{\row }
}
}}
{\xe \v Fir1fixed\:Fir1fixed}
{\xe \v Fir1fixed\:Fir1fixed}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
Fir1fixed::Fir1fixed (const char *  {\i coeffFile}, unsigned  {\i bitshift}, unsigned  {\i number_of_taps} = {\f2 0})}}
\par
{\bkmkstart AAAAAAAAEQ}
{\bkmkend AAAAAAAAEQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Coefficients as a text file (for example from MATLAB). The number of taps is automatically detected when the taps are kept zero. {\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i coeffFile} \cell }{File containing the coefficients \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i bitshift} \cell }{Scaling factor of the coefficients as power of 2: 2^bitshift \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i number_of_taps} \cell }{Number of taps (= number of coefficients) \cell }
{\row }
}
}}
{\xe \v ~Fir1fixed\:Fir1fixed}
{\xe \v Fir1fixed\:~Fir1fixed}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
Fir1fixed::~Fir1fixed ()}}
\par
{\bkmkstart AAAAAAAAER}
{\bkmkend AAAAAAAAER}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Frees the buffer and coefficients \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v filter\:Fir1fixed}
{\xe \v Fir1fixed\:filter}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename Sample > Sample Fir1fixed::filter (Sample  {\i input}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAES}
{\bkmkend AAAAAAAAES}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The actual filtering operation. Takes one sample and returns the filtred one with the same type. The input type is usually short int but can be also int or char if special care it taken against overflows. {\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i input} \cell }{is the input sample of any integer type (int,short,char) \cell }
{\row }
}
}}
{\xe \v getTaps\:Fir1fixed}
{\xe \v Fir1fixed\:getTaps}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned Fir1fixed::getTaps (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAET}
{\bkmkend AAAAAAAAET}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the number of taps \par
}}
{\xe \v reset\:Fir1fixed}
{\xe \v Fir1fixed\:reset}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Fir1fixed::reset ()}}
\par
{\bkmkstart AAAAAAAAEU}
{\bkmkend AAAAAAAAEU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Resets the buffer \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Fir1fixed.h\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Fir1fixed.cpp\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
SignalCleaner Class Reference\par \pard\plain 
{\tc\tcl2 \v SignalCleaner}
{\xe \v SignalCleaner}
{\bkmkstart AAAAAAAAEV}
{\bkmkend AAAAAAAAEV}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
SignalCleaner/SignalCleaner.h\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
SignalCleaner/SignalCleaner.cpp\par
}
\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
File Documentation{\tc \v File Documentation}
\par \pard\plain 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
AudioFile/AudioFile.h File Reference\par \pard\plain 
{\tc\tcl2 \v AudioFile/AudioFile.h}
{\xe \v AudioFile/AudioFile.h}
{\bkmkstart AAAAAAAAAF}
{\bkmkend AAAAAAAAAF}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <iostream>}\par
{\f2 #include <vector>}\par
{\f2 #include <cassert>}\par
{\f2 #include <string>}\par
{\f2 #include <cstring>}\par
{\f2 #include <fstream>}\par
{\f2 #include <unordered_map>}\par
{\f2 #include <iterator>}\par
{\f2 #include <algorithm>}\par
{\f2 #include <limits>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b AudioFile< T >}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Enumerations\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum class {\b AudioFileFormat} \par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Author\par}\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
Adam Stark \par
}}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Copyright\par}\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
Copyright (C) 2017 Adam Stark\par
}}This file is part of the '{\b AudioFile}' library\par
MIT License\par
Copyright (c) 2017 Adam Stark\par
Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\par
The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\par
THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Enumeration Type Documentation\par
\pard\plain 
{\xe \v AudioFileFormat\:AudioFile.h}
{\xe \v AudioFile.h\:AudioFileFormat}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
enum class {\b AudioFileFormat}{\f2 [strong]}}}
\par
{\bkmkstart AAAAAAAAAG}
{\bkmkend AAAAAAAAAG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The different types of audio file, plus some other types to indicate a failure to load a file, or that one hasn't been loaded yet \par
}}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
AudioFile.h\par \pard\plain 
{\tc\tcl2 \v AudioFile/AudioFile.h}
{\xe \v AudioFile/AudioFile.h}
{\bkmkstart AAAAAAAAAA}
{\bkmkend AAAAAAAAAA}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 1 {\cf20 //=======================================================================}\par
29 {\cf20 }{\cf20 //=======================================================================}\par
30 \par
31 {\cf21 #ifndef _AS_AudioFile_h}\par
32 {\cf21 #define _AS_AudioFile_h}\par
33 \par
34 {\cf21 #if defined (_MSC_VER)}\par
35 {\cf21 #undef max}\par
36 {\cf21 #undef min}\par
37 {\cf21 #define NOMINMAX}\par
38 {\cf21 #endif}\par
39 \par
40 {\cf21 #include <iostream>}\par
41 {\cf21 #include <vector>}\par
42 {\cf21 #include <cassert>}\par
43 {\cf21 #include <string>}\par
44 {\cf21 #include <cstring>}\par
45 {\cf21 #include <fstream>}\par
46 {\cf21 #include <unordered_map>}\par
47 {\cf21 #include <iterator>}\par
48 {\cf21 #include <algorithm>}\par
49 {\cf21 #include <limits>}\par
50 \par
51 {\cf20 // disable some warnings on Windows}\par
52 {\cf21 #if defined (_MSC_VER)}\par
53     __pragma(warning (push))\par
54     __pragma(warning (disable : 4244))\par
55     __pragma(warning (disable : 4457))\par
56     __pragma(warning (disable : 4458))\par
57     __pragma(warning (disable : 4389))\par
58     __pragma(warning (disable : 4996))\par
59 {\cf21 #elif defined (__GNUC__)}\par
60     _Pragma({\cf22 "GCC diagnostic push"})\par
61     _Pragma("GCC diagnostic ignored \\"-Wconversion\\"")\par
62     _Pragma("GCC diagnostic ignored \\"-Wsign-compare\\"")\par
63     _Pragma("GCC diagnostic ignored \\"-Wshadow\\"")\par
64 {\cf21 #endif}\par
65 \par
66 {\cf20 //=============================================================}\par
71 {\cf20 }{\cf17 enum class} AudioFileFormat\par
72 \{\par
73     Error,\par
74     NotLoaded,\par
75     Wave,\par
76     Aiff\par
77 \};\par
78 \par
79 {\cf20 //=============================================================}\par
80 {\cf17 template} <{\cf17 class} T>\par
81 {\cf17 class }AudioFile\par
82 \{\par
83 {\cf17 public}:\par
84     \par
85     {\cf20 //=============================================================}\par
86     {\cf17 typedef} std::vector<std::vector<T> > AudioBuffer;\par
87     \par
88     {\cf20 //=============================================================}\par
90 {\cf20 }    AudioFile();\par
91     \par
93     AudioFile (std::string filePath);\par
94         \par
95     {\cf20 //=============================================================}\par
99 {\cf20 }    {\cf18 bool} load (std::string filePath);\par
100     \par
104     {\cf18 bool} save (std::string filePath, AudioFileFormat format = AudioFileFormat::Wave);\par
105         \par
106     {\cf20 //=============================================================}\par
108 {\cf20 }    {\cf18 bool} loadFromMemory (std::vector<uint8_t>& fileData);\par
109     \par
110     {\cf20 //=============================================================}\par
112 {\cf20 }    uint32_t getSampleRate() {\cf17 const};\par
113     \par
115     {\cf18 int} getNumChannels() {\cf17 const};\par
116 \par
118     {\cf18 bool} isMono() {\cf17 const};\par
119     \par
121     {\cf18 bool} isStereo() {\cf17 const};\par
122     \par
124     {\cf18 int} getBitDepth() {\cf17 const};\par
125     \par
127     {\cf18 int} getNumSamplesPerChannel() {\cf17 const};\par
128     \par
130     {\cf18 double} getLengthInSeconds() {\cf17 const};\par
131     \par
133     {\cf18 void} printSummary() {\cf17 const};\par
134     \par
135     {\cf20 //=============================================================}\par
136     \par
140     {\cf18 bool} setAudioBuffer (AudioBuffer& newBuffer);\par
141     \par
145     {\cf18 void} setAudioBufferSize ({\cf18 int} numChannels, {\cf18 int} numSamples);\par
146     \par
150     {\cf18 void} setNumSamplesPerChannel ({\cf18 int} numSamples);\par
151     \par
153     {\cf18 void} setNumChannels ({\cf18 int} numChannels);\par
154     \par
156     {\cf18 void} setBitDepth ({\cf18 int} numBitsPerSample);\par
157     \par
159     {\cf18 void} setSampleRate (uint32_t newSampleRate);\par
160     \par
161     {\cf20 //=============================================================}\par
163 {\cf20 }    {\cf18 void} shouldLogErrorsToConsole ({\cf18 bool} logErrors);\par
164     \par
165     {\cf20 //=============================================================}\par
171 {\cf20 }    AudioBuffer samples;\par
172     \par
173     {\cf20 //=============================================================}\par
176 {\cf20 }    std::string iXMLChunk;\par
177     \par
178 {\cf17 private}:\par
179     \par
180     {\cf20 //=============================================================}\par
181     {\cf17 enum class} Endianness\par
182     \{\par
183         LittleEndian,\par
184         BigEndian\par
185     \};\par
186     \par
187     {\cf20 //=============================================================}\par
188     AudioFileFormat determineAudioFileFormat (std::vector<uint8_t>& fileData);\par
189     {\cf18 bool} decodeWaveFile (std::vector<uint8_t>& fileData);\par
190     {\cf18 bool} decodeAiffFile (std::vector<uint8_t>& fileData);\par
191     \par
192     {\cf20 //=============================================================}\par
193     {\cf18 bool} saveToWaveFile (std::string filePath);\par
194     {\cf18 bool} saveToAiffFile (std::string filePath);\par
195     \par
196     {\cf20 //=============================================================}\par
197     {\cf18 void} clearAudioBuffer();\par
198     \par
199     {\cf20 //=============================================================}\par
200     int32_t fourBytesToInt (std::vector<uint8_t>& source, {\cf18 int} startIndex, Endianness endianness = Endianness::LittleEndian);\par
201     int16_t twoBytesToInt (std::vector<uint8_t>& source, {\cf18 int} startIndex, Endianness endianness = Endianness::LittleEndian);\par
202     {\cf18 int} getIndexOfString (std::vector<uint8_t>& source, std::string s);\par
203     {\cf18 int} getIndexOfChunk (std::vector<uint8_t>& source, {\cf17 const} std::string& chunkHeaderID, {\cf18 int} startIndex, Endianness endianness = Endianness::LittleEndian);\par
204     \par
205     {\cf20 //=============================================================}\par
206     T sixteenBitIntToSample (int16_t sample);\par
207     int16_t sampleToSixteenBitInt (T sample);\par
208     \par
209     {\cf20 //=============================================================}\par
210     uint8_t sampleToSingleByte (T sample);\par
211     T singleByteToSample (uint8_t sample);\par
212     \par
213     uint32_t getAiffSampleRate (std::vector<uint8_t>& fileData, {\cf18 int} sampleRateStartIndex);\par
214     {\cf18 bool} tenByteMatch (std::vector<uint8_t>& v1, {\cf18 int} startIndex1, std::vector<uint8_t>& v2, {\cf18 int} startIndex2);\par
215     {\cf18 void} addSampleRateToAiffData (std::vector<uint8_t>& fileData, uint32_t sampleRate);\par
216     T clamp (T v1, T minValue, T maxValue);\par
217     \par
218     {\cf20 //=============================================================}\par
219     {\cf18 void} addStringToFileData (std::vector<uint8_t>& fileData, std::string s);\par
220     {\cf18 void} addInt32ToFileData (std::vector<uint8_t>& fileData, int32_t i, Endianness endianness = Endianness::LittleEndian);\par
221     {\cf18 void} addInt16ToFileData (std::vector<uint8_t>& fileData, int16_t i, Endianness endianness = Endianness::LittleEndian);\par
222     \par
223     {\cf20 //=============================================================}\par
224     {\cf18 bool} writeDataToFile (std::vector<uint8_t>& fileData, std::string filePath);\par
225     \par
226     {\cf20 //=============================================================}\par
227     {\cf18 void} reportError (std::string errorMessage);\par
228     \par
229     {\cf20 //=============================================================}\par
230     AudioFileFormat audioFileFormat;\par
231     uint32_t sampleRate;\par
232     {\cf18 int} bitDepth;\par
233     {\cf18 bool} logErrorsToConsole \{{\cf17 true}\};\par
234 \};\par
235 \par
236 \par
237 {\cf20 //=============================================================}\par
238 {\cf20 // Pre-defined 10-byte representations of common sample rates}\par
239 {\cf17 static} std::unordered_map <uint32_t, std::vector<uint8_t>> aiffSampleRateTable = \{\par
240     \{8000, \{64, 11, 250, 0, 0, 0, 0, 0, 0, 0\}\},\par
241     \{11025, \{64, 12, 172, 68, 0, 0, 0, 0, 0, 0\}\},\par
242     \{16000, \{64, 12, 250, 0, 0, 0, 0, 0, 0, 0\}\},\par
243     \{22050, \{64, 13, 172, 68, 0, 0, 0, 0, 0, 0\}\},\par
244     \{32000, \{64, 13, 250, 0, 0, 0, 0, 0, 0, 0\}\},\par
245     \{37800, \{64, 14, 147, 168, 0, 0, 0, 0, 0, 0\}\},\par
246     \{44056, \{64, 14, 172, 24, 0, 0, 0, 0, 0, 0\}\},\par
247     \{44100, \{64, 14, 172, 68, 0, 0, 0, 0, 0, 0\}\},\par
248     \{47250, \{64, 14, 184, 146, 0, 0, 0, 0, 0, 0\}\},\par
249     \{48000, \{64, 14, 187, 128, 0, 0, 0, 0, 0, 0\}\},\par
250     \{50000, \{64, 14, 195, 80, 0, 0, 0, 0, 0, 0\}\},\par
251     \{50400, \{64, 14, 196, 224, 0, 0, 0, 0, 0, 0\}\},\par
252     \{88200, \{64, 15, 172, 68, 0, 0, 0, 0, 0, 0\}\},\par
253     \{96000, \{64, 15, 187, 128, 0, 0, 0, 0, 0, 0\}\},\par
254     \{176400, \{64, 16, 172, 68, 0, 0, 0, 0, 0, 0\}\},\par
255     \{192000, \{64, 16, 187, 128, 0, 0, 0, 0, 0, 0\}\},\par
256     \{352800, \{64, 17, 172, 68, 0, 0, 0, 0, 0, 0\}\},\par
257     \{2822400, \{64, 20, 172, 68, 0, 0, 0, 0, 0, 0\}\},\par
258     \{5644800, \{64, 21, 172, 68, 0, 0, 0, 0, 0, 0\}\}\par
259 \};\par
260 \par
261 {\cf20 //=============================================================}\par
262 {\cf17 enum} WavAudioFormat\par
263 \{\par
264     PCM = 0x0001,\par
265     IEEEFloat = 0x0003,\par
266     ALaw = 0x0006,\par
267     MULaw = 0x0007,\par
268     Extensible = 0xFFFE\par
269 \};\par
270 \par
271 {\cf20 //=============================================================}\par
272 {\cf17 enum} AIFFAudioFormat\par
273 \{\par
274     Uncompressed,\par
275     Compressed,\par
276     Error\par
277 \};\par
278 \par
279 {\cf20 //=============================================================}\par
280 {\cf20 /* IMPLEMENTATION */}\par
281 {\cf20 //=============================================================}\par
282 \par
283 {\cf20 //=============================================================}\par
284 {\cf17 template} <{\cf17 class} T>\par
285 AudioFile<T>::AudioFile()\par
286 \{\par
287     {\cf17 static_assert}(std::is_floating_point<T>::value, {\cf22 "ERROR: This version of AudioFile only supports floating point sample formats"});\par
288 \par
289     bitDepth = 16;\par
290     sampleRate = 44100;\par
291     samples.resize (1);\par
292     samples[0].resize (0);\par
293     audioFileFormat = AudioFileFormat::NotLoaded;\par
294 \}\par
295 \par
296 {\cf20 //=============================================================}\par
297 {\cf17 template} <{\cf17 class} T>\par
298 AudioFile<T>::AudioFile (std::string filePath)\par
299  :  AudioFile<T>()\par
300 \{\par
301     load (filePath);\par
302 \}\par
303 \par
304 {\cf20 //=============================================================}\par
305 {\cf17 template} <{\cf17 class} T>\par
306 uint32_t AudioFile<T>::getSampleRate(){\cf17  const}\par
307 {\cf17 }\{\par
308     {\cf19 return} sampleRate;\par
309 \}\par
310 \par
311 {\cf20 //=============================================================}\par
312 {\cf17 template} <{\cf17 class} T>\par
313 {\cf18 int} AudioFile<T>::getNumChannels(){\cf17  const}\par
314 {\cf17 }\{\par
315     {\cf19 return} ({\cf18 int})samples.size();\par
316 \}\par
317 \par
318 {\cf20 //=============================================================}\par
319 {\cf17 template} <{\cf17 class} T>\par
320 {\cf18 bool} AudioFile<T>::isMono(){\cf17  const}\par
321 {\cf17 }\{\par
322     {\cf19 return} getNumChannels() == 1;\par
323 \}\par
324 \par
325 {\cf20 //=============================================================}\par
326 {\cf17 template} <{\cf17 class} T>\par
327 {\cf18 bool} AudioFile<T>::isStereo(){\cf17  const}\par
328 {\cf17 }\{\par
329     {\cf19 return} getNumChannels() == 2;\par
330 \}\par
331 \par
332 {\cf20 //=============================================================}\par
333 {\cf17 template} <{\cf17 class} T>\par
334 {\cf18 int} AudioFile<T>::getBitDepth(){\cf17  const}\par
335 {\cf17 }\{\par
336     {\cf19 return} bitDepth;\par
337 \}\par
338 \par
339 {\cf20 //=============================================================}\par
340 {\cf17 template} <{\cf17 class} T>\par
341 {\cf18 int} AudioFile<T>::getNumSamplesPerChannel(){\cf17  const}\par
342 {\cf17 }\{\par
343     {\cf19 if} (samples.size() > 0)\par
344         {\cf19 return} ({\cf18 int}) samples[0].size();\par
345     {\cf19 else}\par
346         {\cf19 return} 0;\par
347 \}\par
348 \par
349 {\cf20 //=============================================================}\par
350 {\cf17 template} <{\cf17 class} T>\par
351 {\cf18 double} AudioFile<T>::getLengthInSeconds(){\cf17  const}\par
352 {\cf17 }\{\par
353     {\cf19 return} ({\cf18 double})getNumSamplesPerChannel() / (double)sampleRate;\par
354 \}\par
355 \par
356 {\cf20 //=============================================================}\par
357 {\cf17 template} <{\cf17 class} T>\par
358 {\cf18 void} AudioFile<T>::printSummary(){\cf17  const}\par
359 {\cf17 }\{\par
360     std::cout << {\cf22 "|======================================|"} << std::endl;\par
361     std::cout << {\cf22 "Num Channels: "} << getNumChannels() << std::endl;\par
362     std::cout << {\cf22 "Num Samples Per Channel: "} << getNumSamplesPerChannel() << std::endl;\par
363     std::cout << {\cf22 "Sample Rate: "} << sampleRate << std::endl;\par
364     std::cout << {\cf22 "Bit Depth: "} << bitDepth << std::endl;\par
365     std::cout << {\cf22 "Length in Seconds: "} << getLengthInSeconds() << std::endl;\par
366     std::cout << {\cf22 "|======================================|"} << std::endl;\par
367 \}\par
368 \par
369 {\cf20 //=============================================================}\par
370 {\cf17 template} <{\cf17 class} T>\par
371 {\cf18 bool} AudioFile<T>::setAudioBuffer (AudioBuffer& newBuffer)\par
372 \{\par
373     {\cf18 int} numChannels = (int)newBuffer.size();\par
374     \par
375     {\cf19 if} (numChannels <= 0)\par
376     \{\par
377         assert ({\cf17 false} && {\cf22 "The buffer your are trying to use has no channels"});\par
378         {\cf19 return} {\cf17 false};\par
379     \}\par
380     \par
381     {\cf18 size_t} numSamples = newBuffer[0].size();\par
382     \par
383     {\cf20 // set the number of channels}\par
384     samples.resize (newBuffer.size());\par
385     \par
386     {\cf19 for} ({\cf18 int} k = 0; k < getNumChannels(); k++)\par
387     \{\par
388         assert (newBuffer[k].size() == numSamples);\par
389         \par
390         samples[k].resize (numSamples);\par
391         \par
392         {\cf19 for} ({\cf18 size_t} i = 0; i < numSamples; i++)\par
393         \{\par
394             samples[k][i] = newBuffer[k][i];\par
395         \}\par
396     \}\par
397     \par
398     {\cf19 return} {\cf17 true};\par
399 \}\par
400 \par
401 {\cf20 //=============================================================}\par
402 {\cf17 template} <{\cf17 class} T>\par
403 {\cf18 void} AudioFile<T>::setAudioBufferSize ({\cf18 int} numChannels, {\cf18 int} numSamples)\par
404 \{\par
405     samples.resize (numChannels);\par
406     setNumSamplesPerChannel (numSamples);\par
407 \}\par
408 \par
409 {\cf20 //=============================================================}\par
410 {\cf17 template} <{\cf17 class} T>\par
411 {\cf18 void} AudioFile<T>::setNumSamplesPerChannel ({\cf18 int} numSamples)\par
412 \{\par
413     {\cf18 int} originalSize = getNumSamplesPerChannel();\par
414     \par
415     {\cf19 for} ({\cf18 int} i = 0; i < getNumChannels();i++)\par
416     \{\par
417         samples[i].resize (numSamples);\par
418         \par
419         {\cf20 // set any new samples to zero}\par
420         {\cf19 if} (numSamples > originalSize)\par
421             std::fill (samples[i].begin() + originalSize, samples[i].end(), (T)0.);\par
422     \}\par
423 \}\par
424 \par
425 {\cf20 //=============================================================}\par
426 {\cf17 template} <{\cf17 class} T>\par
427 {\cf18 void} AudioFile<T>::setNumChannels ({\cf18 int} numChannels)\par
428 \{\par
429     {\cf18 int} originalNumChannels = getNumChannels();\par
430     {\cf18 int} originalNumSamplesPerChannel = getNumSamplesPerChannel();\par
431     \par
432     samples.resize (numChannels);\par
433     \par
434     {\cf20 // make sure any new channels are set to the right size}\par
435     {\cf20 // and filled with zeros}\par
436     {\cf19 if} (numChannels > originalNumChannels)\par
437     \{\par
438         {\cf19 for} ({\cf18 int} i = originalNumChannels; i < numChannels; i++)\par
439         \{\par
440             samples[i].resize (originalNumSamplesPerChannel);\par
441             std::fill (samples[i].begin(), samples[i].end(), (T)0.);\par
442         \}\par
443     \}\par
444 \}\par
445 \par
446 {\cf20 //=============================================================}\par
447 {\cf17 template} <{\cf17 class} T>\par
448 {\cf18 void} AudioFile<T>::setBitDepth ({\cf18 int} numBitsPerSample)\par
449 \{\par
450     bitDepth = numBitsPerSample;\par
451 \}\par
452 \par
453 {\cf20 //=============================================================}\par
454 {\cf17 template} <{\cf17 class} T>\par
455 {\cf18 void} AudioFile<T>::setSampleRate (uint32_t newSampleRate)\par
456 \{\par
457     sampleRate = newSampleRate;\par
458 \}\par
459 \par
460 {\cf20 //=============================================================}\par
461 {\cf17 template} <{\cf17 class} T>\par
462 {\cf18 void} AudioFile<T>::shouldLogErrorsToConsole ({\cf18 bool} logErrors)\par
463 \{\par
464     logErrorsToConsole = logErrors;\par
465 \}\par
466 \par
467 {\cf20 //=============================================================}\par
468 {\cf17 template} <{\cf17 class} T>\par
469 {\cf18 bool} AudioFile<T>::load (std::string filePath)\par
470 \{\par
471     std::ifstream file (filePath, std::ios::binary);\par
472     \par
473     {\cf20 // check the file exists}\par
474     {\cf19 if} (! file.good())\par
475     \{\par
476         reportError ({\cf22 "ERROR: File doesn't exist or otherwise can't load file\\n"}  + filePath);\par
477         {\cf19 return} {\cf17 false};\par
478     \}\par
479 \par
480     std::vector<uint8_t> fileData;\par
481 \par
482         file.unsetf (std::ios::skipws);\par
483 \par
484         file.seekg (0, std::ios::end);\par
485         {\cf18 size_t} length = file.tellg();\par
486         file.seekg (0, std::ios::beg);\par
487         {\cf20 // allocate}\par
488         fileData.resize (length);\par
489 \par
490         file.read({\cf17 reinterpret_cast<}{\cf18 char}*{\cf17 >} (fileData.data()), length);\par
491         file.close();\par
492 \par
493         {\cf19 if} (file.gcount() != length)\par
494         \{\par
495                 reportError ({\cf22 "ERROR: Couldn't read entire file\\n"} + filePath);\par
496                 {\cf19 return} {\cf17 false};\par
497         \}\par
498     \par
499     {\cf19 return} loadFromMemory (fileData);\par
500 \}\par
501 \par
502 {\cf20 //=============================================================}\par
503 {\cf17 template} <{\cf17 class} T>\par
504 {\cf18 bool} AudioFile<T>::loadFromMemory (std::vector<uint8_t>& fileData)\par
505 \{\par
506     {\cf20 // get audio file format}\par
507     audioFileFormat = determineAudioFileFormat (fileData);\par
508     \par
509     {\cf19 if} (audioFileFormat == AudioFileFormat::Wave)\par
510     \{\par
511         {\cf19 return} decodeWaveFile (fileData);\par
512     \}\par
513     {\cf19 else} {\cf19 if} (audioFileFormat == AudioFileFormat::Aiff)\par
514     \{\par
515         {\cf19 return} decodeAiffFile (fileData);\par
516     \}\par
517     {\cf19 else}\par
518     \{\par
519         reportError ({\cf22 "Audio File Type: Error"});\par
520         {\cf19 return} {\cf17 false};\par
521     \}\par
522 \}\par
523 \par
524 {\cf20 //=============================================================}\par
525 {\cf17 template} <{\cf17 class} T>\par
526 {\cf18 bool} AudioFile<T>::decodeWaveFile (std::vector<uint8_t>& fileData)\par
527 \{\par
528     {\cf20 // -----------------------------------------------------------}\par
529     {\cf20 // HEADER CHUNK}\par
530     std::string headerChunkID (fileData.begin(), fileData.begin() + 4);\par
531     {\cf20 //int32_t fileSizeInBytes = fourBytesToInt (fileData, 4) + 8;}\par
532     std::string format (fileData.begin() + 8, fileData.begin() + 12);\par
533     \par
534     {\cf20 // -----------------------------------------------------------}\par
535     {\cf20 // try and find the start points of key chunks}\par
536     {\cf18 int} indexOfDataChunk = getIndexOfChunk (fileData, {\cf22 "data"}, 12);\par
537     {\cf18 int} indexOfFormatChunk = getIndexOfChunk (fileData, {\cf22 "fmt "}, 12);\par
538     {\cf18 int} indexOfXMLChunk = getIndexOfChunk (fileData, {\cf22 "iXML"}, 12);\par
539     \par
540     {\cf20 // if we can't find the data or format chunks, or the IDs/formats don't seem to be as expected}\par
541     {\cf20 // then it is unlikely we'll able to read this file, so abort}\par
542     {\cf19 if} (indexOfDataChunk == -1 || indexOfFormatChunk == -1 || headerChunkID != {\cf22 "RIFF"} || format != {\cf22 "WAVE"})\par
543     \{\par
544         reportError ({\cf22 "ERROR: this doesn't seem to be a valid .WAV file"});\par
545         {\cf19 return} {\cf17 false};\par
546     \}\par
547     \par
548     {\cf20 // -----------------------------------------------------------}\par
549     {\cf20 // FORMAT CHUNK}\par
550     {\cf18 int} f = indexOfFormatChunk;\par
551     std::string formatChunkID (fileData.begin() + f, fileData.begin() + f + 4);\par
552     {\cf20 //int32_t formatChunkSize = fourBytesToInt (fileData, f + 4);}\par
553     uint16_t audioFormat = twoBytesToInt (fileData, f + 8);\par
554     uint16_t numChannels = twoBytesToInt (fileData, f + 10);\par
555     sampleRate = (uint32_t) fourBytesToInt (fileData, f + 12);\par
556     uint32_t numBytesPerSecond = fourBytesToInt (fileData, f + 16);\par
557     uint16_t numBytesPerBlock = twoBytesToInt (fileData, f + 20);\par
558     bitDepth = (int) twoBytesToInt (fileData, f + 22);\par
559     \par
560     uint16_t numBytesPerSample = {\cf17 static_cast<}uint16_t{\cf17 >} (bitDepth) / 8;\par
561     \par
562     {\cf20 // check that the audio format is PCM or Float or extensible}\par
563     {\cf19 if} (audioFormat != WavAudioFormat::PCM && audioFormat != WavAudioFormat::IEEEFloat && audioFormat != WavAudioFormat::Extensible)\par
564     \{\par
565         reportError ({\cf22 "ERROR: this .WAV file is encoded in a format that this library does not support at present"});\par
566         {\cf19 return} {\cf17 false};\par
567     \}\par
568     \par
569     {\cf20 // check the number of channels is mono or stereo}\par
570     {\cf19 if} (numChannels < 1 || numChannels > 128)\par
571     \{\par
572         reportError ({\cf22 "ERROR: this WAV file seems to be an invalid number of channels (or corrupted?)"});\par
573         {\cf19 return} {\cf17 false};\par
574     \}\par
575     \par
576     {\cf20 // check header data is consistent}\par
577     {\cf19 if} (numBytesPerSecond != {\cf17 static_cast<}uint32_t{\cf17 >} ((numChannels * sampleRate * bitDepth) / 8) || numBytesPerBlock != (numChannels * numBytesPerSample))\par
578     \{\par
579         reportError ({\cf22 "ERROR: the header data in this WAV file seems to be inconsistent"});\par
580         {\cf19 return} {\cf17 false};\par
581     \}\par
582     \par
583     {\cf20 // check bit depth is either 8, 16, 24 or 32 bit}\par
584     {\cf19 if} (bitDepth != 8 && bitDepth != 16 && bitDepth != 24 && bitDepth != 32)\par
585     \{\par
586         reportError ({\cf22 "ERROR: this file has a bit depth that is not 8, 16, 24 or 32 bits"});\par
587         {\cf19 return} {\cf17 false};\par
588     \}\par
589     \par
590     {\cf20 // -----------------------------------------------------------}\par
591     {\cf20 // DATA CHUNK}\par
592     {\cf18 int} d = indexOfDataChunk;\par
593     std::string dataChunkID (fileData.begin() + d, fileData.begin() + d + 4);\par
594     int32_t dataChunkSize = fourBytesToInt (fileData, d + 4);\par
595     \par
596     {\cf18 int} numSamples = dataChunkSize / (numChannels * bitDepth / 8);\par
597     {\cf18 int} samplesStartIndex = indexOfDataChunk + 8;\par
598     \par
599     clearAudioBuffer();\par
600     samples.resize (numChannels);\par
601     \par
602     {\cf19 for} ({\cf18 int} i = 0; i < numSamples; i++)\par
603     \{\par
604         {\cf19 for} ({\cf18 int} channel = 0; channel < numChannels; channel++)\par
605         \{\par
606             {\cf18 int} sampleIndex = samplesStartIndex + (numBytesPerBlock * i) + channel * numBytesPerSample;\par
607             \par
608             {\cf19 if} ((sampleIndex + (bitDepth / 8) - 1) >= fileData.size())\par
609             \{\par
610                 reportError ({\cf22 "ERROR: read file error as the metadata indicates more samples than there are in the file data"});\par
611                 {\cf19 return} {\cf17 false};\par
612             \}\par
613             \par
614             {\cf19 if} (bitDepth == 8)\par
615             \{\par
616                 T sample = singleByteToSample (fileData[sampleIndex]);\par
617                 samples[channel].push_back (sample);\par
618             \}\par
619             {\cf19 else} {\cf19 if} (bitDepth == 16)\par
620             \{\par
621                 int16_t sampleAsInt = twoBytesToInt (fileData, sampleIndex);\par
622                 T sample = sixteenBitIntToSample (sampleAsInt);\par
623                 samples[channel].push_back (sample);\par
624             \}\par
625             {\cf19 else} {\cf19 if} (bitDepth == 24)\par
626             \{\par
627                 int32_t sampleAsInt = 0;\par
628                 sampleAsInt = (fileData[sampleIndex + 2] << 16) | (fileData[sampleIndex + 1] << 8) | fileData[sampleIndex];\par
629                 \par
630                 {\cf19 if} (sampleAsInt & 0x800000) {\cf20 //  if the 24th bit is set, this is a negative number in 24-bit world}\par
631                     sampleAsInt = sampleAsInt | ~0xFFFFFF; {\cf20 // so make sure sign is extended to the 32 bit float}\par
632 \par
633                 T sample = (T)sampleAsInt / (T)8388608.;\par
634                 samples[channel].push_back (sample);\par
635             \}\par
636             {\cf19 else} {\cf19 if} (bitDepth == 32)\par
637             \{\par
638                 int32_t sampleAsInt = fourBytesToInt (fileData, sampleIndex);\par
639                 T sample;\par
640                 \par
641                 {\cf19 if} (audioFormat == WavAudioFormat::IEEEFloat)\par
642                     sample = (T){\cf17 reinterpret_cast<}{\cf18 float}&{\cf17 >} (sampleAsInt);\par
643                 {\cf19 else} {\cf20 // assume PCM}\par
644                     sample = (T) sampleAsInt / {\cf17 static_cast<}{\cf18 float}{\cf17 >} (std::numeric_limits<std::int32_t>::max());\par
645                 \par
646                 samples[channel].push_back (sample);\par
647             \}\par
648             {\cf19 else}\par
649             \{\par
650                 assert ({\cf17 false});\par
651             \}\par
652         \}\par
653     \}\par
654 \par
655     {\cf20 // -----------------------------------------------------------}\par
656     {\cf20 // iXML CHUNK}\par
657     {\cf19 if} (indexOfXMLChunk != -1)\par
658     \{\par
659         int32_t chunkSize = fourBytesToInt (fileData, indexOfXMLChunk + 4);\par
660         iXMLChunk = std::string (({\cf17 const} {\cf18 char}*) &fileData[indexOfXMLChunk + 8], chunkSize);\par
661     \}\par
662 \par
663     {\cf19 return} {\cf17 true};\par
664 \}\par
665 \par
666 {\cf20 //=============================================================}\par
667 {\cf17 template} <{\cf17 class} T>\par
668 {\cf18 bool} AudioFile<T>::decodeAiffFile (std::vector<uint8_t>& fileData)\par
669 \{\par
670     {\cf20 // -----------------------------------------------------------}\par
671     {\cf20 // HEADER CHUNK}\par
672     std::string headerChunkID (fileData.begin(), fileData.begin() + 4);\par
673     {\cf20 //int32_t fileSizeInBytes = fourBytesToInt (fileData, 4, Endianness::BigEndian) + 8;}\par
674     std::string format (fileData.begin() + 8, fileData.begin() + 12);\par
675     \par
676     {\cf18 int} audioFormat = format == {\cf22 "AIFF"} ? AIFFAudioFormat::Uncompressed : format == {\cf22 "AIFC"} ? AIFFAudioFormat::Compressed : AIFFAudioFormat::Error;\par
677     \par
678     {\cf20 // -----------------------------------------------------------}\par
679     {\cf20 // try and find the start points of key chunks}\par
680     {\cf18 int} indexOfCommChunk = getIndexOfChunk (fileData, {\cf22 "COMM"}, 12, Endianness::BigEndian);\par
681     {\cf18 int} indexOfSoundDataChunk = getIndexOfChunk (fileData, {\cf22 "SSND"}, 12, Endianness::BigEndian);\par
682     {\cf18 int} indexOfXMLChunk = getIndexOfChunk (fileData, {\cf22 "iXML"}, 12, Endianness::BigEndian);\par
683     \par
684     {\cf20 // if we can't find the data or format chunks, or the IDs/formats don't seem to be as expected}\par
685     {\cf20 // then it is unlikely we'll able to read this file, so abort}\par
686     {\cf19 if} (indexOfSoundDataChunk == -1 || indexOfCommChunk == -1 || headerChunkID != {\cf22 "FORM"} || audioFormat == AIFFAudioFormat::Error)\par
687     \{\par
688         reportError ({\cf22 "ERROR: this doesn't seem to be a valid AIFF file"});\par
689         {\cf19 return} {\cf17 false};\par
690     \}\par
691 \par
692     {\cf20 // -----------------------------------------------------------}\par
693     {\cf20 // COMM CHUNK}\par
694     {\cf18 int} p = indexOfCommChunk;\par
695     std::string commChunkID (fileData.begin() + p, fileData.begin() + p + 4);\par
696     {\cf20 //int32_t commChunkSize = fourBytesToInt (fileData, p + 4, Endianness::BigEndian);}\par
697     int16_t numChannels = twoBytesToInt (fileData, p + 8, Endianness::BigEndian);\par
698     int32_t numSamplesPerChannel = fourBytesToInt (fileData, p + 10, Endianness::BigEndian);\par
699     bitDepth = (int) twoBytesToInt (fileData, p + 14, Endianness::BigEndian);\par
700     sampleRate = getAiffSampleRate (fileData, p + 16);\par
701     \par
702     {\cf20 // check the sample rate was properly decoded}\par
703     {\cf19 if} (sampleRate == 0)\par
704     \{\par
705         reportError ({\cf22 "ERROR: this AIFF file has an unsupported sample rate"});\par
706         {\cf19 return} {\cf17 false};\par
707     \}\par
708     \par
709     {\cf20 // check the number of channels is mono or stereo}\par
710     {\cf19 if} (numChannels < 1 ||numChannels > 2)\par
711     \{\par
712         reportError ({\cf22 "ERROR: this AIFF file seems to be neither mono nor stereo (perhaps multi-track, or corrupted?)"});\par
713         {\cf19 return} {\cf17 false};\par
714     \}\par
715     \par
716     {\cf20 // check bit depth is either 8, 16, 24 or 32-bit}\par
717     {\cf19 if} (bitDepth != 8 && bitDepth != 16 && bitDepth != 24 && bitDepth != 32)\par
718     \{\par
719         reportError ({\cf22 "ERROR: this file has a bit depth that is not 8, 16, 24 or 32 bits"});\par
720         {\cf19 return} {\cf17 false};\par
721     \}\par
722     \par
723     {\cf20 // -----------------------------------------------------------}\par
724     {\cf20 // SSND CHUNK}\par
725     {\cf18 int} s = indexOfSoundDataChunk;\par
726     std::string soundDataChunkID (fileData.begin() + s, fileData.begin() + s + 4);\par
727     int32_t soundDataChunkSize = fourBytesToInt (fileData, s + 4, Endianness::BigEndian);\par
728     int32_t offset = fourBytesToInt (fileData, s + 8, Endianness::BigEndian);\par
729     {\cf20 //int32_t blockSize = fourBytesToInt (fileData, s + 12, Endianness::BigEndian);}\par
730     \par
731     {\cf18 int} numBytesPerSample = bitDepth / 8;\par
732     {\cf18 int} numBytesPerFrame = numBytesPerSample * numChannels;\par
733     {\cf18 int} totalNumAudioSampleBytes = numSamplesPerChannel * numBytesPerFrame;\par
734     {\cf18 int} samplesStartIndex = s + 16 + (int)offset;\par
735         \par
736     {\cf20 // sanity check the data}\par
737     {\cf19 if} ((soundDataChunkSize - 8) != totalNumAudioSampleBytes || totalNumAudioSampleBytes > {\cf17 static_cast<}{\cf18 long}{\cf17 >}(fileData.size() - samplesStartIndex))\par
738     \{\par
739         reportError ({\cf22 "ERROR: the metadatafor this file doesn't seem right"});\par
740         {\cf19 return} {\cf17 false};\par
741     \}\par
742     \par
743     clearAudioBuffer();\par
744     samples.resize (numChannels);\par
745     \par
746     {\cf19 for} ({\cf18 int} i = 0; i < numSamplesPerChannel; i++)\par
747     \{\par
748         {\cf19 for} ({\cf18 int} channel = 0; channel < numChannels; channel++)\par
749         \{\par
750             {\cf18 int} sampleIndex = samplesStartIndex + (numBytesPerFrame * i) + channel * numBytesPerSample;\par
751             \par
752             {\cf19 if} ((sampleIndex + (bitDepth / 8) - 1) >= fileData.size())\par
753             \{\par
754                 reportError ({\cf22 "ERROR: read file error as the metadata indicates more samples than there are in the file data"});\par
755                 {\cf19 return} {\cf17 false};\par
756             \}\par
757             \par
758             {\cf19 if} (bitDepth == 8)\par
759             \{\par
760                 int8_t sampleAsSigned8Bit = (int8_t)fileData[sampleIndex];\par
761                 T sample = (T)sampleAsSigned8Bit / (T)128.;\par
762                 samples[channel].push_back (sample);\par
763             \}\par
764             {\cf19 else} {\cf19 if} (bitDepth == 16)\par
765             \{\par
766                 int16_t sampleAsInt = twoBytesToInt (fileData, sampleIndex, Endianness::BigEndian);\par
767                 T sample = sixteenBitIntToSample (sampleAsInt);\par
768                 samples[channel].push_back (sample);\par
769             \}\par
770             {\cf19 else} {\cf19 if} (bitDepth == 24)\par
771             \{\par
772                 int32_t sampleAsInt = 0;\par
773                 sampleAsInt = (fileData[sampleIndex] << 16) | (fileData[sampleIndex + 1] << 8) | fileData[sampleIndex + 2];\par
774                 \par
775                 {\cf19 if} (sampleAsInt & 0x800000) {\cf20 //  if the 24th bit is set, this is a negative number in 24-bit world}\par
776                     sampleAsInt = sampleAsInt | ~0xFFFFFF; {\cf20 // so make sure sign is extended to the 32 bit float}\par
777                 \par
778                 T sample = (T)sampleAsInt / (T)8388608.;\par
779                 samples[channel].push_back (sample);\par
780             \}\par
781             {\cf19 else} {\cf19 if} (bitDepth == 32)\par
782             \{\par
783                 int32_t sampleAsInt = fourBytesToInt (fileData, sampleIndex, Endianness::BigEndian);\par
784                 T sample;\par
785                 \par
786                 {\cf19 if} (audioFormat == AIFFAudioFormat::Compressed)\par
787                     sample = (T){\cf17 reinterpret_cast<}{\cf18 float}&{\cf17 >} (sampleAsInt);\par
788                 {\cf19 else} {\cf20 // assume uncompressed}\par
789                     sample = (T) sampleAsInt / {\cf17 static_cast<}{\cf18 float}{\cf17 >} (std::numeric_limits<std::int32_t>::max());\par
790                     \par
791                 samples[channel].push_back (sample);\par
792             \}\par
793             {\cf19 else}\par
794             \{\par
795                 assert ({\cf17 false});\par
796             \}\par
797         \}\par
798     \}\par
799 \par
800     {\cf20 // -----------------------------------------------------------}\par
801     {\cf20 // iXML CHUNK}\par
802     {\cf19 if} (indexOfXMLChunk != -1)\par
803     \{\par
804         int32_t chunkSize = fourBytesToInt (fileData, indexOfXMLChunk + 4);\par
805         iXMLChunk = std::string (({\cf17 const} {\cf18 char}*) &fileData[indexOfXMLChunk + 8], chunkSize);\par
806     \}\par
807     \par
808     {\cf19 return} {\cf17 true};\par
809 \}\par
810 \par
811 {\cf20 //=============================================================}\par
812 {\cf17 template} <{\cf17 class} T>\par
813 uint32_t AudioFile<T>::getAiffSampleRate (std::vector<uint8_t>& fileData, {\cf18 int} sampleRateStartIndex)\par
814 \{\par
815     {\cf19 for} ({\cf17 auto} it : aiffSampleRateTable)\par
816     \{\par
817         {\cf19 if} (tenByteMatch (fileData, sampleRateStartIndex, it.second, 0))\par
818             {\cf19 return} it.first;\par
819     \}\par
820     \par
821     {\cf19 return} 0;\par
822 \}\par
823 \par
824 {\cf20 //=============================================================}\par
825 {\cf17 template} <{\cf17 class} T>\par
826 {\cf18 bool} AudioFile<T>::tenByteMatch (std::vector<uint8_t>& v1, {\cf18 int} startIndex1, std::vector<uint8_t>& v2, {\cf18 int} startIndex2)\par
827 \{\par
828     {\cf19 for} ({\cf18 int} i = 0; i < 10; i++)\par
829     \{\par
830         {\cf19 if} (v1[startIndex1 + i] != v2[startIndex2 + i])\par
831             {\cf19 return} {\cf17 false};\par
832     \}\par
833     \par
834     {\cf19 return} {\cf17 true};\par
835 \}\par
836 \par
837 {\cf20 //=============================================================}\par
838 {\cf17 template} <{\cf17 class} T>\par
839 {\cf18 void} AudioFile<T>::addSampleRateToAiffData (std::vector<uint8_t>& fileData, uint32_t sampleRate)\par
840 \{\par
841     {\cf19 if} (aiffSampleRateTable.count (sampleRate) > 0)\par
842     \{\par
843         {\cf19 for} ({\cf18 int} i = 0; i < 10; i++)\par
844             fileData.push_back (aiffSampleRateTable[sampleRate][i]);\par
845     \}\par
846 \}\par
847 \par
848 {\cf20 //=============================================================}\par
849 {\cf17 template} <{\cf17 class} T>\par
850 {\cf18 bool} AudioFile<T>::save (std::string filePath, AudioFileFormat format)\par
851 \{\par
852     {\cf19 if} (format == AudioFileFormat::Wave)\par
853     \{\par
854         {\cf19 return} saveToWaveFile (filePath);\par
855     \}\par
856     {\cf19 else} {\cf19 if} (format == AudioFileFormat::Aiff)\par
857     \{\par
858         {\cf19 return} saveToAiffFile (filePath);\par
859     \}\par
860     \par
861     {\cf19 return} {\cf17 false};\par
862 \}\par
863 \par
864 {\cf20 //=============================================================}\par
865 {\cf17 template} <{\cf17 class} T>\par
866 {\cf18 bool} AudioFile<T>::saveToWaveFile (std::string filePath)\par
867 \{\par
868     std::vector<uint8_t> fileData;\par
869     \par
870     int32_t dataChunkSize = getNumSamplesPerChannel() * (getNumChannels() * bitDepth / 8);\par
871     int16_t audioFormat = bitDepth == 32 ? WavAudioFormat::IEEEFloat : WavAudioFormat::PCM;\par
872     int32_t formatChunkSize = audioFormat == WavAudioFormat::PCM ? 16 : 18;\par
873     int32_t iXMLChunkSize = {\cf17 static_cast<}int32_t{\cf17 >} (iXMLChunk.size());\par
874     \par
875     {\cf20 // -----------------------------------------------------------}\par
876     {\cf20 // HEADER CHUNK}\par
877     addStringToFileData (fileData, {\cf22 "RIFF"});\par
878     \par
879     {\cf20 // The file size in bytes is the header chunk size (4, not counting RIFF and WAVE) + the format}\par
880     {\cf20 // chunk size (24) + the metadata part of the data chunk plus the actual data chunk size}\par
881     int32_t fileSizeInBytes = 4 + formatChunkSize + 8 + 8 + dataChunkSize;\par
882     {\cf19 if} (iXMLChunkSize > 0)\par
883     \{\par
884         fileSizeInBytes += (8 + iXMLChunkSize);\par
885     \}\par
886 \par
887     addInt32ToFileData (fileData, fileSizeInBytes);\par
888     \par
889     addStringToFileData (fileData, {\cf22 "WAVE"});\par
890     \par
891     {\cf20 // -----------------------------------------------------------}\par
892     {\cf20 // FORMAT CHUNK}\par
893     addStringToFileData (fileData, {\cf22 "fmt "});\par
894     addInt32ToFileData (fileData, formatChunkSize); {\cf20 // format chunk size (16 for PCM)}\par
895     addInt16ToFileData (fileData, audioFormat); {\cf20 // audio format}\par
896     addInt16ToFileData (fileData, (int16_t)getNumChannels()); {\cf20 // num channels}\par
897     addInt32ToFileData (fileData, (int32_t)sampleRate); {\cf20 // sample rate}\par
898     \par
899     int32_t numBytesPerSecond = (int32_t) ((getNumChannels() * sampleRate * bitDepth) / 8);\par
900     addInt32ToFileData (fileData, numBytesPerSecond);\par
901     \par
902     int16_t numBytesPerBlock = getNumChannels() * (bitDepth / 8);\par
903     addInt16ToFileData (fileData, numBytesPerBlock);\par
904     \par
905     addInt16ToFileData (fileData, (int16_t)bitDepth);\par
906     \par
907     {\cf19 if} (audioFormat == WavAudioFormat::IEEEFloat)\par
908         addInt16ToFileData (fileData, 0); {\cf20 // extension size}\par
909     \par
910     {\cf20 // -----------------------------------------------------------}\par
911     {\cf20 // DATA CHUNK}\par
912     addStringToFileData (fileData, {\cf22 "data"});\par
913     addInt32ToFileData (fileData, dataChunkSize);\par
914     \par
915     {\cf19 for} ({\cf18 int} i = 0; i < getNumSamplesPerChannel(); i++)\par
916     \{\par
917         {\cf19 for} ({\cf18 int} channel = 0; channel < getNumChannels(); channel++)\par
918         \{\par
919             {\cf19 if} (bitDepth == 8)\par
920             \{\par
921                 uint8_t {\cf18 byte} = sampleToSingleByte (samples[channel][i]);\par
922                 fileData.push_back ({\cf18 byte});\par
923             \}\par
924             {\cf19 else} {\cf19 if} (bitDepth == 16)\par
925             \{\par
926                 int16_t sampleAsInt = sampleToSixteenBitInt (samples[channel][i]);\par
927                 addInt16ToFileData (fileData, sampleAsInt);\par
928             \}\par
929             {\cf19 else} {\cf19 if} (bitDepth == 24)\par
930             \{\par
931                 int32_t sampleAsIntAgain = (int32_t) (samples[channel][i] * (T)8388608.);\par
932                 \par
933                 uint8_t bytes[3];\par
934                 bytes[2] = (uint8_t) (sampleAsIntAgain >> 16) & 0xFF;\par
935                 bytes[1] = (uint8_t) (sampleAsIntAgain >>  8) & 0xFF;\par
936                 bytes[0] = (uint8_t) sampleAsIntAgain & 0xFF;\par
937                 \par
938                 fileData.push_back (bytes[0]);\par
939                 fileData.push_back (bytes[1]);\par
940                 fileData.push_back (bytes[2]);\par
941             \}\par
942             {\cf19 else} {\cf19 if} (bitDepth == 32)\par
943             \{\par
944                 int32_t sampleAsInt;\par
945                 \par
946                 {\cf19 if} (audioFormat == WavAudioFormat::IEEEFloat)\par
947                     sampleAsInt = (int32_t) {\cf17 reinterpret_cast<}int32_t&{\cf17 >} (samples[channel][i]);\par
948                 {\cf19 else} {\cf20 // assume PCM}\par
949                     sampleAsInt = (int32_t) (samples[channel][i] * std::numeric_limits<int32_t>::max());\par
950                 \par
951                 addInt32ToFileData (fileData, sampleAsInt, Endianness::LittleEndian);\par
952             \}\par
953             {\cf19 else}\par
954             \{\par
955                 assert ({\cf17 false} && {\cf22 "Trying to write a file with unsupported bit depth"});\par
956                 {\cf19 return} {\cf17 false};\par
957             \}\par
958         \}\par
959     \}\par
960     \par
961     {\cf20 // -----------------------------------------------------------}\par
962     {\cf20 // iXML CHUNK}\par
963     {\cf19 if} (iXMLChunkSize > 0) \par
964     \{\par
965         addStringToFileData (fileData, {\cf22 "iXML"});\par
966         addInt32ToFileData (fileData, iXMLChunkSize);\par
967         addStringToFileData (fileData, iXMLChunk);\par
968     \}\par
969     \par
970     {\cf20 // check that the various sizes we put in the metadata are correct}\par
971     {\cf19 if} (fileSizeInBytes != {\cf17 static_cast<}int32_t{\cf17 >} (fileData.size() - 8) || dataChunkSize != (getNumSamplesPerChannel() * getNumChannels() * (bitDepth / 8)))\par
972     \{\par
973         reportError ({\cf22 "ERROR: couldn't save file to "} + filePath);\par
974         {\cf19 return} {\cf17 false};\par
975     \}\par
976     \par
977     {\cf20 // try to write the file}\par
978     {\cf19 return} writeDataToFile (fileData, filePath);\par
979 \}\par
980 \par
981 {\cf20 //=============================================================}\par
982 {\cf17 template} <{\cf17 class} T>\par
983 {\cf18 bool} AudioFile<T>::saveToAiffFile (std::string filePath)\par
984 \{\par
985     std::vector<uint8_t> fileData;\par
986     \par
987     int32_t numBytesPerSample = bitDepth / 8;\par
988     int32_t numBytesPerFrame = numBytesPerSample * getNumChannels();\par
989     int32_t totalNumAudioSampleBytes = getNumSamplesPerChannel() * numBytesPerFrame;\par
990     int32_t soundDataChunkSize = totalNumAudioSampleBytes + 8;\par
991     int32_t iXMLChunkSize = {\cf17 static_cast<}int32_t{\cf17 >} (iXMLChunk.size());\par
992     \par
993     {\cf20 // -----------------------------------------------------------}\par
994     {\cf20 // HEADER CHUNK}\par
995     addStringToFileData (fileData, {\cf22 "FORM"});\par
996     \par
997     {\cf20 // The file size in bytes is the header chunk size (4, not counting FORM and AIFF) + the COMM}\par
998     {\cf20 // chunk size (26) + the metadata part of the SSND chunk plus the actual data chunk size}\par
999     int32_t fileSizeInBytes = 4 + 26 + 16 + totalNumAudioSampleBytes;\par
1000     {\cf19 if} (iXMLChunkSize > 0)\par
1001     \{\par
1002         fileSizeInBytes += (8 + iXMLChunkSize);\par
1003     \}\par
1004 \par
1005     addInt32ToFileData (fileData, fileSizeInBytes, Endianness::BigEndian);\par
1006     \par
1007     addStringToFileData (fileData, {\cf22 "AIFF"});\par
1008     \par
1009     {\cf20 // -----------------------------------------------------------}\par
1010     {\cf20 // COMM CHUNK}\par
1011     addStringToFileData (fileData, {\cf22 "COMM"});\par
1012     addInt32ToFileData (fileData, 18, Endianness::BigEndian); {\cf20 // commChunkSize}\par
1013     addInt16ToFileData (fileData, getNumChannels(), Endianness::BigEndian); {\cf20 // num channels}\par
1014     addInt32ToFileData (fileData, getNumSamplesPerChannel(), Endianness::BigEndian); {\cf20 // num samples per channel}\par
1015     addInt16ToFileData (fileData, bitDepth, Endianness::BigEndian); {\cf20 // bit depth}\par
1016     addSampleRateToAiffData (fileData, sampleRate);\par
1017     \par
1018     {\cf20 // -----------------------------------------------------------}\par
1019     {\cf20 // SSND CHUNK}\par
1020     addStringToFileData (fileData, {\cf22 "SSND"});\par
1021     addInt32ToFileData (fileData, soundDataChunkSize, Endianness::BigEndian);\par
1022     addInt32ToFileData (fileData, 0, Endianness::BigEndian); {\cf20 // offset}\par
1023     addInt32ToFileData (fileData, 0, Endianness::BigEndian); {\cf20 // block size}\par
1024     \par
1025     {\cf19 for} ({\cf18 int} i = 0; i < getNumSamplesPerChannel(); i++)\par
1026     \{\par
1027         {\cf19 for} ({\cf18 int} channel = 0; channel < getNumChannels(); channel++)\par
1028         \{\par
1029             {\cf19 if} (bitDepth == 8)\par
1030             \{\par
1031                 uint8_t {\cf18 byte} = sampleToSingleByte (samples[channel][i]);\par
1032                 fileData.push_back ({\cf18 byte});\par
1033             \}\par
1034             {\cf19 else} {\cf19 if} (bitDepth == 16)\par
1035             \{\par
1036                 int16_t sampleAsInt = sampleToSixteenBitInt (samples[channel][i]);\par
1037                 addInt16ToFileData (fileData, sampleAsInt, Endianness::BigEndian);\par
1038             \}\par
1039             {\cf19 else} {\cf19 if} (bitDepth == 24)\par
1040             \{\par
1041                 int32_t sampleAsIntAgain = (int32_t) (samples[channel][i] * (T)8388608.);\par
1042                 \par
1043                 uint8_t bytes[3];\par
1044                 bytes[0] = (uint8_t) (sampleAsIntAgain >> 16) & 0xFF;\par
1045                 bytes[1] = (uint8_t) (sampleAsIntAgain >>  8) & 0xFF;\par
1046                 bytes[2] = (uint8_t) sampleAsIntAgain & 0xFF;\par
1047                 \par
1048                 fileData.push_back (bytes[0]);\par
1049                 fileData.push_back (bytes[1]);\par
1050                 fileData.push_back (bytes[2]);\par
1051             \}\par
1052             {\cf19 else} {\cf19 if} (bitDepth == 32)\par
1053             \{\par
1054                 {\cf20 // write samples as signed integers (no implementation yet for floating point, but looking at WAV implementation should help)}\par
1055                 int32_t sampleAsInt = (int32_t) (samples[channel][i] * std::numeric_limits<int32_t>::max());\par
1056                 addInt32ToFileData (fileData, sampleAsInt, Endianness::BigEndian);\par
1057             \}\par
1058             {\cf19 else}\par
1059             \{\par
1060                 assert ({\cf17 false} && {\cf22 "Trying to write a file with unsupported bit depth"});\par
1061                 {\cf19 return} {\cf17 false};\par
1062             \}\par
1063         \}\par
1064     \}\par
1065 \par
1066     {\cf20 // -----------------------------------------------------------}\par
1067     {\cf20 // iXML CHUNK}\par
1068     {\cf19 if} (iXMLChunkSize > 0)\par
1069     \{\par
1070         addStringToFileData (fileData, {\cf22 "iXML"});\par
1071         addInt32ToFileData (fileData, iXMLChunkSize, Endianness::BigEndian);\par
1072         addStringToFileData (fileData, iXMLChunk);\par
1073     \}\par
1074     \par
1075     {\cf20 // check that the various sizes we put in the metadata are correct}\par
1076     {\cf19 if} (fileSizeInBytes != {\cf17 static_cast<}int32_t{\cf17 >} (fileData.size() - 8) || soundDataChunkSize != getNumSamplesPerChannel() *  numBytesPerFrame + 8)\par
1077     \{\par
1078         reportError ({\cf22 "ERROR: couldn't save file to "} + filePath);\par
1079         {\cf19 return} {\cf17 false};\par
1080     \}\par
1081     \par
1082     {\cf20 // try to write the file}\par
1083     {\cf19 return} writeDataToFile (fileData, filePath);\par
1084 \}\par
1085 \par
1086 {\cf20 //=============================================================}\par
1087 {\cf17 template} <{\cf17 class} T>\par
1088 {\cf18 bool} AudioFile<T>::writeDataToFile (std::vector<uint8_t>& fileData, std::string filePath)\par
1089 \{\par
1090     std::ofstream outputFile (filePath, std::ios::binary);\par
1091     \par
1092     {\cf19 if} (outputFile.is_open())\par
1093     \{\par
1094         {\cf19 for} ({\cf18 size_t} i = 0; i < fileData.size(); i++)\par
1095         \{\par
1096             {\cf18 char} value = (char) fileData[i];\par
1097             outputFile.write (&value, {\cf17 sizeof} ({\cf18 char}));\par
1098         \}\par
1099         \par
1100         outputFile.close();\par
1101         \par
1102         {\cf19 return} {\cf17 true};\par
1103     \}\par
1104     \par
1105     {\cf19 return} {\cf17 false};\par
1106 \}\par
1107 \par
1108 {\cf20 //=============================================================}\par
1109 {\cf17 template} <{\cf17 class} T>\par
1110 {\cf18 void} AudioFile<T>::addStringToFileData (std::vector<uint8_t>& fileData, std::string s)\par
1111 \{\par
1112     {\cf19 for} ({\cf18 size_t} i = 0; i < s.length();i++)\par
1113         fileData.push_back ((uint8_t) s[i]);\par
1114 \}\par
1115 \par
1116 {\cf20 //=============================================================}\par
1117 {\cf17 template} <{\cf17 class} T>\par
1118 {\cf18 void} AudioFile<T>::addInt32ToFileData (std::vector<uint8_t>& fileData, int32_t i, Endianness endianness)\par
1119 \{\par
1120     uint8_t bytes[4];\par
1121     \par
1122     {\cf19 if} (endianness == Endianness::LittleEndian)\par
1123     \{\par
1124         bytes[3] = (i >> 24) & 0xFF;\par
1125         bytes[2] = (i >> 16) & 0xFF;\par
1126         bytes[1] = (i >> 8) & 0xFF;\par
1127         bytes[0] = i & 0xFF;\par
1128     \}\par
1129     {\cf19 else}\par
1130     \{\par
1131         bytes[0] = (i >> 24) & 0xFF;\par
1132         bytes[1] = (i >> 16) & 0xFF;\par
1133         bytes[2] = (i >> 8) & 0xFF;\par
1134         bytes[3] = i & 0xFF;\par
1135     \}\par
1136     \par
1137     {\cf19 for} ({\cf18 int} i = 0; i < 4; i++)\par
1138         fileData.push_back (bytes[i]);\par
1139 \}\par
1140 \par
1141 {\cf20 //=============================================================}\par
1142 {\cf17 template} <{\cf17 class} T>\par
1143 {\cf18 void} AudioFile<T>::addInt16ToFileData (std::vector<uint8_t>& fileData, int16_t i, Endianness endianness)\par
1144 \{\par
1145     uint8_t bytes[2];\par
1146     \par
1147     {\cf19 if} (endianness == Endianness::LittleEndian)\par
1148     \{\par
1149         bytes[1] = (i >> 8) & 0xFF;\par
1150         bytes[0] = i & 0xFF;\par
1151     \}\par
1152     {\cf19 else}\par
1153     \{\par
1154         bytes[0] = (i >> 8) & 0xFF;\par
1155         bytes[1] = i & 0xFF;\par
1156     \}\par
1157     \par
1158     fileData.push_back (bytes[0]);\par
1159     fileData.push_back (bytes[1]);\par
1160 \}\par
1161 \par
1162 {\cf20 //=============================================================}\par
1163 {\cf17 template} <{\cf17 class} T>\par
1164 {\cf18 void} AudioFile<T>::clearAudioBuffer()\par
1165 \{\par
1166     {\cf19 for} ({\cf18 size_t} i = 0; i < samples.size();i++)\par
1167     \{\par
1168         samples[i].clear();\par
1169     \}\par
1170     \par
1171     samples.clear();\par
1172 \}\par
1173 \par
1174 {\cf20 //=============================================================}\par
1175 {\cf17 template} <{\cf17 class} T>\par
1176 AudioFileFormat AudioFile<T>::determineAudioFileFormat (std::vector<uint8_t>& fileData)\par
1177 \{\par
1178     std::string header (fileData.begin(), fileData.begin() + 4);\par
1179     \par
1180     {\cf19 if} (header == {\cf22 "RIFF"})\par
1181         {\cf19 return} AudioFileFormat::Wave;\par
1182     {\cf19 else} {\cf19 if} (header == {\cf22 "FORM"})\par
1183         {\cf19 return} AudioFileFormat::Aiff;\par
1184     {\cf19 else}\par
1185         {\cf19 return} AudioFileFormat::Error;\par
1186 \}\par
1187 \par
1188 {\cf20 //=============================================================}\par
1189 {\cf17 template} <{\cf17 class} T>\par
1190 int32_t AudioFile<T>::fourBytesToInt (std::vector<uint8_t>& source, {\cf18 int} startIndex, Endianness endianness)\par
1191 \{\par
1192     int32_t result;\par
1193     \par
1194     {\cf19 if} (endianness == Endianness::LittleEndian)\par
1195         result = (source[startIndex + 3] << 24) | (source[startIndex + 2] << 16) | (source[startIndex + 1] << 8) | source[startIndex];\par
1196     {\cf19 else}\par
1197         result = (source[startIndex] << 24) | (source[startIndex + 1] << 16) | (source[startIndex + 2] << 8) | source[startIndex + 3];\par
1198     \par
1199     {\cf19 return} result;\par
1200 \}\par
1201 \par
1202 {\cf20 //=============================================================}\par
1203 {\cf17 template} <{\cf17 class} T>\par
1204 int16_t AudioFile<T>::twoBytesToInt (std::vector<uint8_t>& source, {\cf18 int} startIndex, Endianness endianness)\par
1205 \{\par
1206     int16_t result;\par
1207     \par
1208     {\cf19 if} (endianness == Endianness::LittleEndian)\par
1209         result = (source[startIndex + 1] << 8) | source[startIndex];\par
1210     {\cf19 else}\par
1211         result = (source[startIndex] << 8) | source[startIndex + 1];\par
1212     \par
1213     {\cf19 return} result;\par
1214 \}\par
1215 \par
1216 {\cf20 //=============================================================}\par
1217 {\cf17 template} <{\cf17 class} T>\par
1218 {\cf18 int} AudioFile<T>::getIndexOfString (std::vector<uint8_t>& source, std::string stringToSearchFor)\par
1219 \{\par
1220     {\cf18 int} index = -1;\par
1221     {\cf18 int} stringLength = (int)stringToSearchFor.length();\par
1222     \par
1223     {\cf19 for} ({\cf18 size_t} i = 0; i < source.size() - stringLength;i++)\par
1224     \{\par
1225         std::string section (source.begin() + i, source.begin() + i + stringLength);\par
1226         \par
1227         {\cf19 if} (section == stringToSearchFor)\par
1228         \{\par
1229             index = {\cf17 static_cast<}{\cf18 int}{\cf17 >} (i);\par
1230             {\cf19 break};\par
1231         \}\par
1232     \}\par
1233     \par
1234     {\cf19 return} index;\par
1235 \}\par
1236 \par
1237 {\cf20 //=============================================================}\par
1238 {\cf17 template} <{\cf17 class} T>\par
1239 {\cf18 int} AudioFile<T>::getIndexOfChunk (std::vector<uint8_t>& source, {\cf17 const} std::string& chunkHeaderID, {\cf18 int} startIndex, Endianness endianness)\par
1240 \{\par
1241     {\cf17 constexpr} {\cf18 int} dataLen = 4;\par
1242     {\cf19 if} (chunkHeaderID.size() != dataLen)\par
1243     \{\par
1244         assert ({\cf17 false} && {\cf22 "Invalid chunk header ID string"});\par
1245         {\cf19 return} -1;\par
1246     \}\par
1247 \par
1248     {\cf18 int} i = startIndex;\par
1249     {\cf19 while} (i < source.size() - dataLen)\par
1250     \{\par
1251         {\cf19 if} (memcmp (&source[i], chunkHeaderID.data(), dataLen) == 0)\par
1252         \{\par
1253             {\cf19 return} i;\par
1254         \}\par
1255 \par
1256         i += dataLen;\par
1257         {\cf17 auto} chunkSize = fourBytesToInt (source, i, endianness);\par
1258         i += (dataLen + chunkSize);\par
1259     \}\par
1260 \par
1261     {\cf19 return} -1;\par
1262 \}\par
1263 \par
1264 {\cf20 //=============================================================}\par
1265 {\cf17 template} <{\cf17 class} T>\par
1266 T AudioFile<T>::sixteenBitIntToSample (int16_t sample)\par
1267 \{\par
1268     {\cf19 return} {\cf17 static_cast<}T{\cf17 >} (sample) / {\cf17 static_cast<}T{\cf17 >} (32768.);\par
1269 \}\par
1270 \par
1271 {\cf20 //=============================================================}\par
1272 {\cf17 template} <{\cf17 class} T>\par
1273 int16_t AudioFile<T>::sampleToSixteenBitInt (T sample)\par
1274 \{\par
1275     sample = clamp (sample, -1., 1.);\par
1276     {\cf19 return} {\cf17 static_cast<}int16_t{\cf17 >} (sample * 32767.);\par
1277 \}\par
1278 \par
1279 {\cf20 //=============================================================}\par
1280 {\cf17 template} <{\cf17 class} T>\par
1281 uint8_t AudioFile<T>::sampleToSingleByte (T sample)\par
1282 \{\par
1283     sample = clamp (sample, -1., 1.);\par
1284     sample = (sample + 1.) / 2.;\par
1285     {\cf19 return} {\cf17 static_cast<}uint8_t{\cf17 >} (sample * 255.);\par
1286 \}\par
1287 \par
1288 {\cf20 //=============================================================}\par
1289 {\cf17 template} <{\cf17 class} T>\par
1290 T AudioFile<T>::singleByteToSample (uint8_t sample)\par
1291 \{\par
1292     {\cf19 return} {\cf17 static_cast<}T{\cf17 >} (sample - 128) / {\cf17 static_cast<}T{\cf17 >} (128.);\par
1293 \}\par
1294 \par
1295 {\cf20 //=============================================================}\par
1296 {\cf17 template} <{\cf17 class} T>\par
1297 T AudioFile<T>::clamp (T value, T minValue, T maxValue)\par
1298 \{\par
1299     value = std::min (value, maxValue);\par
1300     value = std::max (value, minValue);\par
1301     {\cf19 return} value;\par
1302 \}\par
1303 \par
1304 {\cf20 //=============================================================}\par
1305 {\cf17 template} <{\cf17 class} T>\par
1306 {\cf18 void} AudioFile<T>::reportError (std::string errorMessage)\par
1307 \{\par
1308     {\cf19 if} (logErrorsToConsole)\par
1309         std::cout << errorMessage << std::endl;\par
1310 \}\par
1311 \par
1312 {\cf21 #if defined (_MSC_VER)}\par
1313     __pragma(warning (pop))\par
1314 {\cf21 #elif defined (__GNUC__)}\par
1315     _Pragma({\cf22 "GCC diagnostic pop"})\par
1316 {\cf21 #endif}\par
1317 \par
1318 {\cf21 #endif }{\cf20 /* AudioFile_h */}{\cf21 }\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
correlate.h\par \pard\plain 
{\tc\tcl2 \v correlate/correlate.h}
{\xe \v correlate/correlate.h}
{\bkmkstart AAAAAAAAAB}
{\bkmkend AAAAAAAAAB}
{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 1 {\cf20 //}\par
2 {\cf20 // Created by ross on 08/03/2022.}\par
3 {\cf20 //}\par
4 \par
5 {\cf21 #ifndef CORRELATE_H}\par
6 {\cf21 #define CORRELATE_H}\par
7 {\cf21 #include "AudioFile/AudioFile.h"}\par
8 {\cf21 #include <cmath>}\par
9 \par
10 \par
11 \par
12 {\cf18 double} wcorr_rho(AudioFile<double> x, AudioFile<double> y);\par
13 \par
14 {\cf18 double} wcorr_cov(AudioFile<double> x, AudioFile<double> y);\par
15 \par
16 {\cf18 double} wcorr_stdev(AudioFile<double> signal);\par
17 \par
18 {\cf18 double} wcorr_mean(AudioFile<double> signal);\par
19 \par
20 {\cf18 double} wcorr_rho2snr({\cf18 double} p, {\cf18 bool} as_db);\par
21 \par
22 \par
23 {\cf21 #endif}\par
24 \par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Fir1.h\par \pard\plain 
{\bkmkstart AAAAAAAAAC}
{\bkmkend AAAAAAAAAC}
{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 1 {\cf20 /*}\par
2 {\cf20 License: MIT License (http://www.opensource.org/licenses/mit-license.php)}\par
3 {\cf20 }\par
4 {\cf20 Permission is hereby granted, free of charge, to any person obtaining a copy}\par
5 {\cf20 of this software and associated documentation files (the "Software"), to deal}\par
6 {\cf20 in the Software without restriction, including without limitation the rights}\par
7 {\cf20 to use, copy, modify, merge, publish, distribute, sublicense, and/or sell}\par
8 {\cf20 copies of the Software, and to permit persons to whom the Software is}\par
9 {\cf20 furnished to do so, subject to the following conditions:}\par
10 {\cf20 }\par
11 {\cf20 The above copyright notice and this permission notice shall be included in}\par
12 {\cf20 all copies or substantial portions of the Software.}\par
13 {\cf20 }\par
14 {\cf20 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR}\par
15 {\cf20 IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,}\par
16 {\cf20 FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE}\par
17 {\cf20 AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER}\par
18 {\cf20 LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,}\par
19 {\cf20 OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN}\par
20 {\cf20 THE SOFTWARE.}\par
21 {\cf20 */}\par
22 \par
23 {\cf20 /* (C) 2013-2021 Graeme Hattan & Bernd Porr */}\par
24 \par
25 {\cf21 #ifndef FIR1_H}\par
26 {\cf21 #define FIR1_H}\par
27 \par
28 {\cf21 #include <stdio.h>}\par
29 {\cf21 #include <vector>}\par
30 \par
36 {\cf17 class }Fir1 \{\par
37 {\cf17 public}:\par
43         {\cf17 template} <{\cf18 unsigned} nTaps> Fir1({\cf17 const} {\cf18 double} (&_coefficients)[nTaps]) :\par
44                 coefficients(new double[nTaps]),\par
45                 buffer(new double[nTaps]()),\par
46                 taps(nTaps) \{\par
47                 {\cf19 for}({\cf18 unsigned} i=0;i<nTaps;i++) \{\par
48                         coefficients[i] = _coefficients[i];\par
49                         buffer[i] = 0;\par
50                 \}\par
51         \}\par
52 \par
57         Fir1(std::vector<double> _coefficients) \{\par
58                 initWithVector(_coefficients);\par
59         \}\par
60 \par
66         Fir1({\cf18 double} *coefficients, {\cf18 unsigned} number_of_taps);\par
67 \par
74         Fir1({\cf17 const} {\cf18 char}* coeffFile, {\cf18 unsigned} number_of_taps = 0);\par
75 \par
81         Fir1({\cf18 unsigned} number_of_taps);\par
82 \par
86         ~Fir1();\par
87 \par
88         \par
94         {\cf17 inline} {\cf18 double} filter({\cf18 double} input) \{\par
95                 {\cf17 const} {\cf18 double} *coeff     = coefficients;\par
96                 {\cf17 const} {\cf18 double} *{\cf17 const} coeff_end = coefficients + taps;\par
97                 \par
98                 {\cf18 double} *buf_val = buffer + offset;\par
99                 \par
100                 *buf_val = input;\par
101                 {\cf18 double} output_ = 0;\par
102                 \par
103                 {\cf19 while}(buf_val >= buffer)\par
104                         output_ += *buf_val-- * *coeff++;\par
105                 \par
106                 buf_val = buffer + taps-1;\par
107                 \par
108                 {\cf19 while}(coeff < coeff_end)\par
109                         output_ += *buf_val-- * *coeff++;\par
110                 \par
111                 {\cf19 if}(++offset >= taps)\par
112                         offset = 0;\par
113                 \par
114                 {\cf19 return} output_;\par
115         \}\par
116 \par
117 \par
124         {\cf17 inline} {\cf18 void} lms_update({\cf18 double} error) \{\par
125                 {\cf18 double} *coeff     = coefficients;\par
126                 {\cf17 const} {\cf18 double} *coeff_end = coefficients + taps;\par
127         \par
128                 {\cf18 double} *buf_val = buffer + offset;\par
129                 \par
130                 {\cf19 while}(buf_val >= buffer) \{\par
131                         *coeff++ += *buf_val-- * error * mu;\par
132                 \}\par
133                 \par
134                 buf_val = buffer + taps-1;\par
135                 \par
136                 {\cf19 while}(coeff < coeff_end) \{\par
137                         *coeff++ += *buf_val-- * error * mu;\par
138                 \}\par
139         \}\par
140 \par
145         {\cf18 void} setLearningRate({\cf18 double} _mu) \{mu = _mu;\};\par
146 \par
150         {\cf18 double} getLearningRate() \{{\cf19 return} mu;\};\par
151 \par
155         {\cf18 void} reset();\par
156 \par
160         {\cf18 void} zeroCoeff();\par
161 \par
170         {\cf18 void} getCoeff({\cf18 double}* coeff_data, {\cf18 unsigned} number_of_taps) {\cf17 const};\par
171 \par
175         std::vector<double> getCoeffVector(){\cf17  const }\{\par
176                 {\cf19 return} std::vector<double>(coefficients,coefficients+taps);\par
177         \}\par
178 \par
182         {\cf18 unsigned} getTaps() \{{\cf19 return} taps;\};\par
183 \par
189         {\cf17 inline} {\cf18 double} getTapInputPower() \{\par
190                 {\cf18 double} *buf_val = buffer;\par
191                 \par
192                 {\cf18 double} p = 0;\par
193                 \par
194                 {\cf19 for}({\cf18 unsigned} i = 0; i < taps; i++) \{\par
195                         p += (*buf_val) * (*buf_val);\par
196                         buf_val++;\par
197                 \}\par
198         \par
199                 {\cf19 return} p;\par
200         \}\par
201 \par
202 {\cf17 private}:\par
203         {\cf18 void} initWithVector(std::vector<double> _coefficients);\par
204         \par
205         {\cf18 double}        *coefficients;\par
206         {\cf18 double}        *buffer;\par
207         {\cf18 unsigned}      taps;\par
208         {\cf18 unsigned}      offset = 0;\par
209         {\cf18 double}        mu = 0;\par
210 \};\par
211 \par
212 {\cf21 #endif}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Fir1fixed.h\par \pard\plain 
{\bkmkstart AAAAAAAAAD}
{\bkmkend AAAAAAAAAD}
{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 1 {\cf20 /*}\par
2 {\cf20 License: MIT License (http://www.opensource.org/licenses/mit-license.php)}\par
3 {\cf20 }\par
4 {\cf20 Permission is hereby granted, free of charge, to any person obtaining a copy}\par
5 {\cf20 of this software and associated documentation files (the "Software"), to deal}\par
6 {\cf20 in the Software without restriction, including without limitation the rights}\par
7 {\cf20 to use, copy, modify, merge, publish, distribute, sublicense, and/or sell}\par
8 {\cf20 copies of the Software, and to permit persons to whom the Software is}\par
9 {\cf20 furnished to do so, subject to the following conditions:}\par
10 {\cf20 }\par
11 {\cf20 The above copyright notice and this permission notice shall be included in}\par
12 {\cf20 all copies or substantial portions of the Software.}\par
13 {\cf20 }\par
14 {\cf20 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR}\par
15 {\cf20 IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,}\par
16 {\cf20 FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE}\par
17 {\cf20 AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER}\par
18 {\cf20 LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,}\par
19 {\cf20 OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN}\par
20 {\cf20 THE SOFTWARE.}\par
21 {\cf20 */}\par
22 \par
23 {\cf20 /* (C) 2013-2020 Graeme Hattan & Bernd Porr */}\par
24 \par
25 {\cf21 #ifndef FIR1FIXED_H}\par
26 {\cf21 #define FIR1FIXED_H}\par
27 \par
28 {\cf21 #include <stdio.h>}\par
29 {\cf21 #include <cmath>}\par
30 {\cf21 #include <complex>}\par
31 \par
35 {\cf17 class }Fir1fixed \{\par
36 {\cf17 public}:\par
43         Fir1fixed({\cf18 short} {\cf18 int} *coefficients, \par
44                   {\cf18 unsigned} bitshift,\par
45                   {\cf18 unsigned} number_of_taps);\par
46 \par
52         {\cf17 template} <{\cf18 unsigned} nTaps> Fir1fixed({\cf17 const} {\cf18 short} {\cf18 int} (&_coefficients)[nTaps],\par
53                                             {\cf18 unsigned} bitshift) :\par
54                 coefficients(new short int[nTaps]),\par
55                 buffer(new int[nTaps]),  \par
56                 taps(nTaps),\par
57                 numberOfBitsToShift(bitshift) \{\par
58                         {\cf19 for}({\cf18 unsigned} i = 0; i < nTaps; i++) \{\par
59                                 coefficients[i] = _coefficients[i];\par
60                                 buffer[i] = 0;\par
61                         \}\par
62                 \}\par
63 \par
72         Fir1fixed({\cf17 const} {\cf18 char}* coeffFile,\par
73                   {\cf18 unsigned}  bitshift,\par
74                   {\cf18 unsigned} number_of_taps = 0);\par
75 \par
83         {\cf17 template} <{\cf17 typename} Sample> {\cf17 inline} Sample filter(Sample input) \{\par
84                 {\cf18 short} {\cf18 int} *coeff     = coefficients;\par
85                 {\cf18 short} {\cf18 int} *coeff_end = coefficients + taps;\par
86                 \par
87                 {\cf18 int} *buf_val = buffer + offset;\par
88                 \par
89                 *buf_val = {\cf17 static_cast<}Sample{\cf17 >}(input);\par
90                 {\cf18 int} output_ = 0;\par
91                 \par
92                 {\cf19 while}(buf_val >= buffer)\par
93                         output_ += *buf_val-- * *coeff++;\par
94                 \par
95                 buf_val = buffer + taps-1;\par
96                 \par
97                 {\cf19 while}(coeff < coeff_end)\par
98                         output_ += *buf_val-- * *coeff++;\par
99                 \par
100                 {\cf19 if}(++offset >= taps)\par
101                         offset = 0;\par
102                 \par
103                 {\cf19 return} {\cf17 static_cast<}Sample{\cf17 >}(output_ >> numberOfBitsToShift);\par
104         \}\par
105 \par
106         \par
110         ~Fir1fixed();\par
111 \par
115         {\cf18 void} reset();\par
116 \par
120         {\cf18 unsigned} getTaps() \{{\cf19 return} taps;\};\par
121         \par
122 {\cf17 private}:\par
123         {\cf18 short} {\cf18 int}        *coefficients;\par
124         {\cf18 int}              *buffer;\par
125         {\cf18 unsigned}         taps;\par
126         {\cf18 unsigned}         offset = 0;\par
127         {\cf18 unsigned}         numberOfBitsToShift;\par
128 \};\par
129 \par
130 {\cf21 #endif}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
SignalCleaner.h\par \pard\plain 
{\tc\tcl2 \v SignalCleaner/SignalCleaner.h}
{\xe \v SignalCleaner/SignalCleaner.h}
{\bkmkstart AAAAAAAAAE}
{\bkmkend AAAAAAAAAE}
{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 1 {\cf20 //}\par
2 {\cf20 // Created by ross on 08/03/2022.}\par
3 {\cf20 //}\par
4 \par
5 {\cf21 #ifndef FIR1_SIGNALCLEANER_H}\par
6 {\cf21 #define FIR1_SIGNALCLEANER_H}\par
7 {\cf21 #include <Fir1.h>}\par
8 {\cf21 #include "AudioFile/AudioFile.h"}\par
9 {\cf21 #include <cmath>}\par
10 \par
11 \par
12 {\cf17 class }SignalCleaner \{\par
13 {\cf17 public}:\par
14     AudioFile<double> noisey_signal;\par
15     AudioFile<double> noise_source;\par
16     AudioFile<double> output;\par
17     AudioFile<double> clean;\par
18 \par
19     SignalCleaner(std::string noisey_signal_path, std::string noise_source_path, {\cf18 unsigned} nr_taps, {\cf18 double} learning_rate);\par
20 \par
21     {\cf18 bool} SaveFiltered(std::string);\par
22 \par
23     {\cf18 void} Filter();\par
24 \par
25     {\cf18 void} PrintSummaries();\par
26 \par
27 \par
28 {\cf17 private}:\par
29     Fir1 internal_fir;\par
30 \par
31     {\cf18 bool} FileExists(std::string filename);\par
32 \};\par
33 \par
34 \par
35 {\cf21 #endif }{\cf20 //FIR1_SIGNALCLEANER_H}\par
}

\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid Index\par 
\pard\plain 
{\tc \v Index}
{\field\fldedit {\*\fldinst INDEX \\c2 \\*MERGEFORMAT}{\fldrslt INDEX}}
}
